;; -*- lexical-binding:t -*-
;; This file is autogenerated by `doom-reload-doom-autoloads', DO NOT EDIT !!


;;;;;;  (0 0 0 0))
;;; Generated autoloads from core/autoload/ui.el

(autoload 'doom-resize-window "/home/maruku/.emacs.d/core/autoload/ui" "\
Resize a window to NEW-SIZE. If HORIZONTAL, do it width-wise.
If FORCE-P is omitted when `window-size-fixed' is non-nil, resizing will fail.

\(fn WINDOW NEW-SIZE &optional HORIZONTAL FORCE-P)" nil nil)

(autoload 'doom-quit-p "~/.emacs.d/core/autoload/ui" "\
Prompt the user for confirmation when killing Emacs.

Returns t if it is safe to kill this session. Does not prompt if no real buffers
are open.

\(fn &optional PROMPT)" nil nil)

(autoload 'doom*recenter "~/.emacs.d/core/autoload/ui" "\
Generic advisor for recentering window (typically :after other functions).

\(fn &rest _)" nil nil)

(autoload 'doom*shut-up "~/.emacs.d/core/autoload/ui" "\
Generic advisor for silencing noisy functions.

\(fn ORIG-FN &rest ARGS)" nil nil)

(autoload 'doom|apply-ansi-color-to-compilation-buffer "~/.emacs.d/core/autoload/ui" "\
Applies ansi codes to the compilation buffers. Meant for
`compilation-filter-hook'.

\(fn)" nil nil)

(autoload 'doom/toggle-line-numbers "~/.emacs.d/core/autoload/ui" "\
Toggle line numbers.

Cycles through regular, relative and no line numbers. The order depends on what
`display-line-numbers-type' is set to. If you're using Emacs 26+, and
visual-line-mode is on, this skips relative and uses visual instead.

See `display-line-numbers' for what these values mean.

\(fn)" t nil)

(autoload 'doom/reload-theme "~/.emacs.d/core/autoload/ui" "\
Reset the current color theme and fonts.

\(fn)" t nil)

(autoload 'doom/delete-frame "~/.emacs.d/core/autoload/ui" "\
Delete the current frame, but ask for confirmation if it isn't empty.

\(fn)" t nil)

(autoload 'doom/window-zoom "~/.emacs.d/core/autoload/ui" "\
Close other windows to focus on this one. Activate again to undo this. If the
window changes before then, the undo expires.

Alternatively, use `doom/window-enlargen'.

\(fn)" t nil)

(autoload 'doom/window-enlargen "~/.emacs.d/core/autoload/ui" "\
Enlargen the current window to focus on this one. Does not close other
windows (unlike `doom/window-zoom') Activate again to undo.

\(fn)" t nil)

(autoload 'doom/reload-font "~/.emacs.d/core/autoload/ui" "\
Reload `doom-font', `doom-variable-pitch-font', and `doom-unicode-font', if
set.

\(fn)" t nil)

(autoload 'doom/set-frame-opacity "~/.emacs.d/core/autoload/ui" "\
Interactively change the current frame's opacity.

OPACITY is an integer between 0 to 100, inclusive.

\(fn OPACITY)" t nil)

(autoload 'doom/clone-and-narrow-buffer "~/.emacs.d/core/autoload/ui" "\
Restrict editing in this buffer to the current region, indirectly. With CLONE-P,
clone the buffer and hard-narrow the selection. If mark isn't active, then widen
the buffer (if narrowed).

Inspired from http://demonastery.org/2013/04/emacs-evil-narrow-region/

\(fn BEG END &optional CLONE-P)" t nil)

(defvar doom-big-font-mode nil "\
Non-nil if Doom-Big-Font mode is enabled.
See the `doom-big-font-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `doom-big-font-mode'.")

(custom-autoload 'doom-big-font-mode "/home/maruku/.emacs.d/core/autoload/ui" nil)

(autoload 'doom-big-font-mode "~/.emacs.d/core/autoload/ui" "\
A global mode that resizes the font, for streams, screen-sharing and
presentations.

Uses `doom-big-font' when enabled.

\(fn &optional ARG)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/text"
;;;;;;  "core/autoload/text.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/text.el

(autoload 'doom-surrounded-p "/home/maruku/.emacs.d/core/autoload/text" "\
Returns t if point is surrounded by a brace delimiter: {[(

If INLINE is non-nil, only returns t if braces are on the same line, and
whitespace is balanced on either side of the cursor.

If INLINE is nil, returns t if the opening and closing braces are on adjacent
lines, above and below, with only whitespace in between.

\(fn PAIR &optional INLINE BALANCED)" nil nil)

(autoload 'doom/backward-to-bol-or-indent "~/.emacs.d/core/autoload/text" "\
Jump between the indentation column (first non-whitespace character) and the
beginning of the line. The opposite of
`doom/forward-to-last-non-comment-or-eol'.

\(fn)" t nil)

(autoload 'doom/forward-to-last-non-comment-or-eol "~/.emacs.d/core/autoload/text" "\
Jumps between the last non-blank, non-comment character in the line and the
true end of the line. The opposite of `doom/backward-to-bol-or-indent'.

\(fn)" t nil)

(autoload 'doom/dumb-indent "~/.emacs.d/core/autoload/text" "\
Inserts a tab character (or spaces x tab-width).

\(fn)" t nil)

(autoload 'doom/dumb-dedent "~/.emacs.d/core/autoload/text" "\
Dedents the current line.

\(fn)" t nil)

(autoload 'doom/backward-kill-to-bol-and-indent "~/.emacs.d/core/autoload/text" "\
Kill line to the first non-blank character. If invoked again
afterwards, kill line to beginning of line.

\(fn)" t nil)

(autoload 'doom/retab "~/.emacs.d/core/autoload/text" "\
Converts tabs-to-spaces or spaces-to-tabs within BEG and END (defaults to
buffer start and end, to make indentation consistent. Which it does depends on
the value of `indent-tab-mode'.

If ARG (universal argument) is non-nil, retab the current buffer using the
opposite indentation style.

\(fn ARG &optional BEG END)" t nil)

(autoload 'doom/delete-trailing-newlines "~/.emacs.d/core/autoload/text" "\
Trim trailing newlines.

Respects `require-final-newline'.

\(fn)" t nil)

(autoload 'doom/dos2unix "~/.emacs.d/core/autoload/text" "\
Convert the current buffer to a Unix file encoding.

\(fn)" t nil)

(autoload 'doom/unix2dos "~/.emacs.d/core/autoload/text" "\
Convert the current buffer to a DOS file encoding.

\(fn)" t nil)

(autoload 'doom|enable-delete-trailing-whitespace "~/.emacs.d/core/autoload/text" "\
Enables the automatic deletion of trailing whitespaces upon file save.

i.e. enables `ws-butler-mode' in the current buffer.

\(fn)" nil nil)

(autoload 'doom|disable-delete-trailing-whitespace "~/.emacs.d/core/autoload/text" "\
Disables the automatic deletion of trailing whitespaces upon file save.

i.e. disables `ws-butler-mode' in the current buffer.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/sessions"
;;;;;;  "core/autoload/sessions.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/sessions.el

(autoload 'doom-save-session "/home/maruku/.emacs.d/core/autoload/sessions" "\
TODO

\(fn &optional FILE)" nil nil)

(autoload 'doom-load-session "~/.emacs.d/core/autoload/sessions" "\
TODO

\(fn &optional FILE)" nil nil)

(autoload 'doom-session-file "~/.emacs.d/core/autoload/sessions" "\
TODO

\(fn)" nil nil)

(autoload 'doom-restore-session-handler "~/.emacs.d/core/autoload/sessions" "\
TODO

\(fn &rest _)" nil nil)

(add-to-list 'command-switch-alist (cons "--restore" #'doom-restore-session-handler))

(autoload 'doom/quickload-session "~/.emacs.d/core/autoload/sessions" "\
TODO

\(fn)" t nil)

(autoload 'doom/quicksave-session "~/.emacs.d/core/autoload/sessions" "\
TODO

\(fn)" t nil)

(autoload 'doom/load-session "~/.emacs.d/core/autoload/sessions" "\
TODO

\(fn FILE)" t nil)

(autoload 'doom/save-session "~/.emacs.d/core/autoload/sessions" "\
TODO

\(fn FILE)" t nil)

(defalias 'doom/restart #'restart-emacs)

(autoload 'doom/restart-and-restore "~/.emacs.d/core/autoload/sessions" "\
TODO

\(fn &optional DEBUG)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/scratch"
;;;;;;  "core/autoload/scratch.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/scratch.el

(autoload 'doom-scratch-buffer "/home/maruku/.emacs.d/core/autoload/scratch" "\
Return a scratchpad buffer in major MODE with TEXT in it.

If FILE is a valid path, open it as if it were a persistent scratchpad.

\(fn &optional FILE MODE TEXT)" nil nil)

(autoload 'doom/open-scratch-buffer "~/.emacs.d/core/autoload/scratch" "\
Opens a scratch pad window in the same major-mode.

If ARG (universal argument), then open a persistent scratch pad buffer. You'll
be prompted for its name, or to open a previously created. These are stored in
`doom-scratch-files-dir'.

If a region is active, copy its contents to the scratch pad.

\(fn &optional ARG)" t nil)

(autoload 'doom/switch-to-scratch-buffer "~/.emacs.d/core/autoload/scratch" "\
Switches to a scratch pad buffer in the current window.

Otherwise, does exactly what `doom/open-scratch-buffer' does.

\(fn &optional ARG)" t nil)

(autoload 'doom/delete-scratch-files "~/.emacs.d/core/autoload/scratch" "\
Deletes all scratch buffers in `doom-scratch-files-dir'.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/projects"
;;;;;;  "core/autoload/projects.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/projects.el

(autoload 'projectile-relevant-known-projects "/home/maruku/.emacs.d/.local/packages/elpa/projectile-20190323.904/projectile")

(autoload 'without-project-cache! "/home/maruku/.emacs.d/core/autoload/projects" "\
Run BODY with projectile's project-root cache disabled. This is necessary if
you want to interactive with a project other than the one you're in.

\(fn &rest BODY)" nil t)

(autoload 'project-file-exists-p! "~/.emacs.d/core/autoload/projects" "\
Checks if the project has the specified FILES.
Paths are relative to the project root, unless they start with ./ or ../ (in
which case they're relative to `default-directory'). If they start with a slash,
they are absolute.

\(fn FILES)" nil t)

(autoload 'doom/reload-project "~/.emacs.d/core/autoload/projects" "\
Reload the project root cache.

\(fn)" t nil)

(autoload 'doom/find-file-in-other-project "~/.emacs.d/core/autoload/projects" "\
Preforms `projectile-find-file' in a known project of your choosing.

\(fn PROJECT-ROOT)" t nil)

(autoload 'doom/browse-in-other-project "~/.emacs.d/core/autoload/projects" "\
Preforms `find-file' in a known project of your choosing.

\(fn PROJECT-ROOT)" t nil)

(defalias 'doom-project-p #'projectile-project-p)

(defalias 'doom-project-root #'projectile-project-root)

(autoload 'doom-project-name "~/.emacs.d/core/autoload/projects" "\
Return the name of the current project.

\(fn &optional DIR)" nil nil)

(autoload 'doom-project-expand "~/.emacs.d/core/autoload/projects" "\
Expand NAME to project root.

\(fn NAME &optional DIR)" nil nil)

(autoload 'doom-project-find-file "~/.emacs.d/core/autoload/projects" "\
Fuzzy-find a file under DIR.

\(fn DIR)" nil nil)

(autoload 'doom-project-browse "~/.emacs.d/core/autoload/projects" "\
Traverse a file structure starting linearly from DIR.

\(fn DIR)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/packages"
;;;;;;  "core/autoload/packages.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/packages.el

(autoload 'doom-refresh-packages-maybe "/home/maruku/.emacs.d/core/autoload/packages" "\
Refresh ELPA packages, if it hasn't been refreshed recently.

\(fn &optional FORCE-P)" nil nil)

(autoload 'doom-package-backend "~/.emacs.d/core/autoload/packages" "\
Get which backend the package NAME was installed with. Can either be elpa,
quelpa or emacs (built-in). Throws an error if NOERROR is nil and the package
isn't installed.

\(fn NAME &optional NOERROR)" nil nil)

(autoload 'doom-package-outdated-p "~/.emacs.d/core/autoload/packages" "\
Determine whether NAME (a symbol) is outdated or not. If outdated, returns a
list, whose car is NAME, and cdr the current version list and latest version
list of the package.

\(fn NAME)" nil nil)

(autoload 'doom-package-installed-p "~/.emacs.d/core/autoload/packages" "\
TODO

\(fn NAME)" nil nil)

(autoload 'doom-package-prop "~/.emacs.d/core/autoload/packages" "\
Return PROPerty in NAME's plist.

\(fn NAME PROP &optional EVAL)" nil nil)

(autoload 'doom-package-different-backend-p "~/.emacs.d/core/autoload/packages" "\
Return t if a package named NAME (a symbol) has a new backend than what it
was installed with. Returns nil otherwise, or if package isn't installed.

\(fn NAME)" nil nil)

(autoload 'doom-package-different-recipe-p "~/.emacs.d/core/autoload/packages" "\
Return t if a package named NAME (a symbol) has a different recipe than it
was installed with.

\(fn NAME)" nil nil)

(autoload 'doom-find-packages "~/.emacs.d/core/autoload/packages" "\
Retrieves a list of primary packages (i.e. non-dependencies). Each element is
a cons cell, whose car is the package symbol and whose cdr is the quelpa recipe
\(if any).

You can build a filtering criteria using one or more of the following
properties:

  :backend 'quelpa|'elpa|'emacs|'any
    Include packages installed through 'quelpa, 'elpa or 'emacs. 'any is the
    wildcard.
  :installed BOOL|'any
    t = only include installed packages
    nil = exclude installed packages
  :private BOOL|'any
    t = only include user-installed packages
    nil = exclude user-installed packages
  :core BOOL|'any
    t = only include Doom core packages
    nil = exclude Doom core packages
  :disabled BOOL|'any
    t = only include disabled packages
    nil = exclude disabled packages
  :ignored BOOL|'any
    t = only include ignored packages
    nil = exclude ignored packages
  :pinned BOOL|ARCHIVE
    Only return packages that are pinned (t), not pinned (nil) or pinned to a
    specific archive (stringp)
  :deps BOOL
    Includes the package's dependencies (t) or not (nil).

The resulting list is sorted unless :sort nil is passed to this function.

Warning: this function is expensive, as it re-evaluates your all packages.el
files.

\(fn &key (INSTALLED \\='any) (PRIVATE \\='any) (DISABLED \\='any) (PINNED \\='any) (IGNORED \\='any) (CORE \\='any) SORT CHANGED BACKEND DEPS)" nil nil)

(autoload 'doom-package-list "~/.emacs.d/core/autoload/packages" "\
Retrieve a list of explicitly declared packages from enabled modules.

This excludes core packages listed in `doom-core-packages'.

If ALL-P, gather packages unconditionally across all modules, including disabled
ones.

\(fn &optional ALL-P)" nil nil)

(autoload 'doom-get-package-alist "~/.emacs.d/core/autoload/packages" "\
Returns a list of all desired packages, their dependencies and their desc
objects, in the order of their `package! blocks.'

\(fn)" nil nil)

(autoload 'doom-get-depending-on "~/.emacs.d/core/autoload/packages" "\
Return a list of packages that depend on the package named NAME.

\(fn NAME &optional NOERROR)" nil nil)

(autoload 'doom-get-dependencies-for "~/.emacs.d/core/autoload/packages" "\
Return a list of dependencies for a package.

\(fn NAME &optional RECURSIVE NOERROR)" nil nil)

(autoload 'doom-get-outdated-packages "~/.emacs.d/core/autoload/packages" "\
Return a list of packages that are out of date. Each element is a list,
containing (PACKAGE-SYMBOL OLD-VERSION-LIST NEW-VERSION-LIST).

If INCLUDE-FROZEN-P is non-nil, check frozen packages as well.

Used by `doom-packages-update'.

\(fn &optional INCLUDE-FROZEN-P)" nil nil)

(autoload 'doom-get-orphaned-packages "~/.emacs.d/core/autoload/packages" "\
Return a list of symbols representing packages that are no longer needed or
depended on.

Used by `doom-packages-autoremove'.

\(fn)" nil nil)

(autoload 'doom-get-missing-packages "~/.emacs.d/core/autoload/packages" "\
Return a list of requested packages that aren't installed or built-in, but
are enabled (with a `package!' directive). Each element is a list whose CAR is
the package symbol, and whose CDR is a plist taken from that package's
`package!' declaration.

Used by `doom-packages-install'.

\(fn)" nil nil)

(autoload 'doom-install-package "~/.emacs.d/core/autoload/packages" "\
Installs package NAME with optional quelpa RECIPE (see `quelpa-recipe' for an
example; the package name can be omitted).

\(fn NAME &optional PLIST)" nil nil)

(autoload 'doom-update-package "~/.emacs.d/core/autoload/packages" "\
Updates package NAME (a symbol) if it is out of date, using quelpa or
package.el as appropriate.

\(fn NAME &optional FORCE-P)" nil nil)

(autoload 'doom-delete-package "~/.emacs.d/core/autoload/packages" "\
Uninstalls package NAME if it exists, and clears it from `quelpa-cache'.

\(fn NAME &optional FORCE-P)" nil nil)

(autoload 'doom/reload-packages "~/.emacs.d/core/autoload/packages" "\
Reload `doom-packages', `package' and `quelpa'.

\(fn)" t nil)

(autoload 'doom/update-package "~/.emacs.d/core/autoload/packages" "\
Prompts the user with a list of outdated packages and updates the selected
package. Use this interactively. Use `doom-update-package' for direct
calls.

\(fn PKG)" t nil)

(function-put 'doom/update-package 'interactive-only 't)

(autoload 'doom*package-delete "~/.emacs.d/core/autoload/packages" "\
Update `quelpa-cache' upon a successful `package-delete'.

\(fn DESC &rest _)" nil nil)

(advice-add #'package-delete :after #'doom*package-delete)

(advice-add #'package-autoremove :override #'doom//autoremove)

(advice-add #'package-install-selected-packages :override #'doom//install)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/message"
;;;;;;  "core/autoload/message.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/message.el

(autoload 'doom-color-apply "/home/maruku/.emacs.d/core/autoload/message" "\
Apply CODE to formatted MESSAGE with ARGS. CODE is derived from any of
`doom-message-fg', `doom-message-bg' or `doom-message-fx'.

In a noninteractive session, this wraps the result in ansi color codes.
Otherwise, it maps colors to a term-color-* face.

\(fn STYLE TEXT)" nil nil)

(autoload 'format! "~/.emacs.d/core/autoload/message" "\
An alternative to `format' that understands (color ...) and converts them
into faces or ANSI codes depending on the type of sesssion we're in.

\(fn MESSAGE &rest ARGS)" nil t)

(autoload 'print! "~/.emacs.d/core/autoload/message" "\
Uses `message' in interactive sessions and `princ' otherwise (prints to
standard out).

Can be colored using (color ...) blocks:

  (print! \"Hello %s\" (bold (blue \"How are you?\")))
  (print! \"Hello %s\" (red \"World\"))
  (print! (green \"Great %s!\") \"success\")

Uses faces in interactive sessions and ANSI codes otherwise.

\(fn MESSAGE &rest ARGS)" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/hydras"
;;;;;;  "core/autoload/hydras.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/hydras.el
 (autoload 'doom-text-zoom-hydra/body "core/autoload/hydras" nil nil)
 (autoload 'doom-window-nav-hydra/body "core/autoload/hydras" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/help"
;;;;;;  "core/autoload/help.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/help.el

(autoload 'doom-active-minor-modes "/home/maruku/.emacs.d/core/autoload/help" "\
Return a list of active minor-mode symbols.

\(fn)" nil nil)

(autoload 'doom/describe-autodefs "~/.emacs.d/core/autoload/help" "\
Open the documentation of Doom autodefs.

What is an autodef? It's a function or macro that is always defined, even if its
containing module is disabled (in which case it will safely no-op). This
syntactic sugar lets you use them without needing to check if they are
available.

\(fn AUTODEF)" t nil)

(autoload 'doom/describe-active-minor-mode "~/.emacs.d/core/autoload/help" "\
Get information on an active minor mode. Use `describe-minor-mode' for a
selection of all minor-modes, active or not.

\(fn MODE)" t nil)

(autoload 'doom/describe-module "~/.emacs.d/core/autoload/help" "\
Open the documentation of CATEGORY MODULE.

CATEGORY is a keyword and MODULE is a symbol. e.g. :feature and 'evil.

Automatically selects a) the module at point (in private init files), b) the
module derived from a `featurep!' or `require!' call, c) the module that the
current file is in, or d) the module associated with the current major mode (see
`doom--module-mode-alist').

\(fn CATEGORY MODULE)" t nil)

(global-set-key [remap describe-package] #'doom/describe-package)

(autoload 'doom/describe-package "~/.emacs.d/core/autoload/help" "\
Like `describe-packages', but is Doom aware.

Only shows installed packages. Includes information about where packages are
defined and configured.

If prefix arg is prsent, refresh the cache.

\(fn PACKAGE)" t nil)

(autoload 'doom/describe-symbol "~/.emacs.d/core/autoload/help" "\
Show help for SYMBOL, a variable, function or macro.

\(fn SYMBOL)" t nil)

(defalias 'doom/help 'doom/open-manual)

(autoload 'doom/open-manual "~/.emacs.d/core/autoload/help" "\
TODO

\(fn)" t nil)

(autoload 'doom/open-news "~/.emacs.d/core/autoload/help" "\
TODO

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/files"
;;;;;;  "core/autoload/files.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/files.el

(autoload 'doom-files-in "/home/maruku/.emacs.d/core/autoload/files" "\
Returns a list of files/directories in PATH-OR-PATHS (one string path or a
list of them).

FILTER is a function or symbol that takes one argument (the path). If it returns
non-nil, the entry will be excluded.

MAP is a function or symbol which will be used to transform each entry in the
results.

TYPE determines what kind of path will be included in the results. This can be t
\(files and folders), 'files or 'dirs.

By default, this function returns paths relative to PATH-OR-PATHS if it is a
single path. If it a list of paths, this function returns absolute paths.
Otherwise, by setting RELATIVE-TO to a path, the results will be transformed to
be relative to it.

The search recurses up to DEPTH and no further. DEPTH is an integer.

MATCH is a string regexp. Only entries that match it will be included.

\(fn PATH-OR-PATHS &rest REST &key FILTER MAP FULL NOSORT (FOLLOW-SYMLINKS t) (TYPE \\='files) (RELATIVE-TO (unless full default-directory)) (DEPTH 99999) (MINDEPTH 0) (MATCH \"/[^.]\"))" nil nil)

(autoload 'doom/delete-this-file "~/.emacs.d/core/autoload/files" "\
Delete FILENAME (defaults to the file associated with current buffer) and
kills the buffer. If FORCE-P, force the deletion (don't ask for confirmation).

\(fn &optional PATH FORCE-P)" t nil)

(autoload 'doom/copy-this-file "~/.emacs.d/core/autoload/files" "\
Copy current buffer's file to NEW-PATH. If FORCE-P, overwrite the destination
file if it exists, without confirmation.

\(fn NEW-PATH &optional FORCE-P)" t nil)

(autoload 'doom/move-this-file "~/.emacs.d/core/autoload/files" "\
Move current buffer's file to NEW-PATH. If FORCE-P, overwrite the destination
file if it exists, without confirmation.

\(fn NEW-PATH &optional FORCE-P)" t nil)

(autoload 'doom/sudo-find-file "~/.emacs.d/core/autoload/files" "\
Open FILE as root.

\(fn FILE)" t nil)

(autoload 'doom/sudo-this-file "~/.emacs.d/core/autoload/files" "\
Open the current file as root.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/debug"
;;;;;;  "core/autoload/debug.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/debug.el

(autoload 'doom-info "/home/maruku/.emacs.d/core/autoload/debug" "\
Returns diagnostic information about the current Emacs session in markdown,
ready to be pasted in a bug report on github.

\(fn)" nil nil)

(autoload 'doom/info "~/.emacs.d/core/autoload/debug" "\
Collects some debug information about your Emacs session, formats it into
markdown and copies it to your clipboard, ready to be pasted into bug reports!

\(fn)" t nil)

(autoload 'doom/am-i-secure "~/.emacs.d/core/autoload/debug" "\
Test to see if your root certificates are securely configured in emacs.

\(fn)" t nil)

(function-put 'doom/am-i-secure 'interactive-only 't)

(autoload 'doom/version "~/.emacs.d/core/autoload/debug" "\
Display the current version of Doom & Emacs, including the current Doom
branch and commit.

\(fn)" t nil)

(autoload 'doom/copy-backtrace "~/.emacs.d/core/autoload/debug" "\
Copy the contents of the *Backtrace* window into your clipboard for easy
pasting into a bug report or discord.

\(fn)" t nil)

(autoload 'doom/open-vanilla-sandbox "~/.emacs.d/core/autoload/debug" "\
Open the Emacs Lisp sandbox.

This is a test bed for running Emacs Lisp in an instance of Emacs with varying
amounts of Doom loaded, including:

  a) vanilla Emacs (nothing loaded),
  b) vanilla Doom (only Doom core) and
  c) Doom + modules - your private config.

This is done without sacrificing access to installed packages. Use the sandbox
to reproduce bugs and determine if Doom is to blame.

\(fn)" t nil)

(autoload 'doom/open-bug-report "~/.emacs.d/core/autoload/debug" "\
Open a markdown buffer destinated to populate the New Issue page on Doom
Emacs' issue tracker.

If called when a backtrace buffer is present, it and the output of `doom-info'
will be automatically appended to the result.

\(fn)" t nil)

(autoload 'doom/toggle-profiler "~/.emacs.d/core/autoload/debug" "\
Toggle the Emacs profiler. Run it again to see the profiling report.

\(fn)" t nil)

(autoload 'doom/profile-emacs "~/.emacs.d/core/autoload/debug" "\
Profile the startup time of Emacs in the background with ESUP.
If INIT-FILE is non-nil, profile that instead of USER-INIT-FILE.

\(fn)" t nil)

(advice-add #'esup :override #'doom/profile-emacs)

(autoload 'doom/toggle-debug-mode "~/.emacs.d/core/autoload/debug" "\
Toggle `debug-on-error' and `doom-debug-mode' for verbose logging.

\(fn &optional ARG)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/config"
;;;;;;  "core/autoload/config.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/config.el

(autoload 'doom/open-private-config "/home/maruku/.emacs.d/core/autoload/config" "\
TODO

\(fn)" t nil)

(autoload 'doom/find-file-in-private-config "~/.emacs.d/core/autoload/config" "\
TODO

\(fn)" t nil)

(autoload 'doom/reload "~/.emacs.d/core/autoload/config" "\
Reloads your config. This is experimental!

If called from a noninteractive session, this will try to communicate with a
live server (if one is found) to tell it to run this function.

If called from an interactive session, tries to reload autoloads files (if
necessary), reinistalize doom (via `doom-initialize') and reloads your private
init.el and config.el. Then runs `doom-reload-hook'.

\(fn &optional FORCE-P)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/cli" "core/autoload/cli.el"
;;;;;;  (0 0 0 0))
;;; Generated autoloads from core/autoload/cli.el

(autoload 'doom//autoloads "/home/maruku/.emacs.d/core/autoload/cli" "\
TODO

\(fn &optional YES)" t nil)

(autoload 'doom//update "~/.emacs.d/core/autoload/cli" "\
TODO

\(fn &optional YES)" t nil)

(autoload 'doom//upgrade "~/.emacs.d/core/autoload/cli" "\
TODO

\(fn &optional YES)" t nil)

(autoload 'doom//install "~/.emacs.d/core/autoload/cli" "\
TODO

\(fn &optional YES)" t nil)

(autoload 'doom//autoremove "~/.emacs.d/core/autoload/cli" "\
TODO

\(fn &optional YES)" t nil)

(autoload 'doom//refresh "~/.emacs.d/core/autoload/cli" "\
TODO

\(fn &optional YES)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/cache"
;;;;;;  "core/autoload/cache.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/cache.el

(autoload 'with-cache! "/home/maruku/.emacs.d/core/autoload/cache" "\
Runs BODY with a different default `doom-cache-location'.

\(fn LOCATION &rest BODY)" nil t)

(function-put 'with-cache! 'lisp-indent-function 'defun)

(autoload 'doom-cache-persist "~/.emacs.d/core/autoload/cache" "\
Persist VARIABLES (list of symbols) in LOCATION (symbol).

This populates these variables with cached values, if one exists, and saves them
to file when Emacs quits.

Warning: this is incompatible with buffer-local variables.

\(fn LOCATION VARIABLES)" nil nil)

(autoload 'doom-cache-desist "~/.emacs.d/core/autoload/cache" "\
Unregisters VARIABLES (list of symbols) in LOCATION (symbol) from
`doom-cache-alists', thus preventing them from being saved between sessions.
Does not affect the actual variables themselves or their values.

\(fn LOCATION &optional VARIABLES)" nil nil)

(autoload 'doom-cache-get "~/.emacs.d/core/autoload/cache" "\
Retrieve KEY from LOCATION (defaults to `doom-cache-location'), if it exists
and hasn't expired.

\(fn KEY &optional LOCATION)" nil nil)

(autoload 'doom-cache-set "~/.emacs.d/core/autoload/cache" "\
Set KEY to VALUE in the cache. TTL is the time (in seconds) until this cache
entry expires. LOCATION is the super-key to store this cache item under; the
default is `doom-cache-location'. 

\(fn KEY VALUE &optional TTL LOCATION)" nil nil)

(autoload 'doom-cache-exists "~/.emacs.d/core/autoload/cache" "\
Returns t if KEY exists at LOCATION (defaults to `doom-cache-location').

\(fn KEY &optional LOCATION)" nil nil)

(autoload 'doom-cache-clear "~/.emacs.d/core/autoload/cache" "\
Clear a cache LOCATION (defaults to `doom-cache-location').

\(fn &optional LOCATION)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/core/autoload/buffers"
;;;;;;  "core/autoload/buffers.el" (0 0 0 0))
;;; Generated autoloads from core/autoload/buffers.el

(defvar doom-real-buffer-functions '(doom-dired-buffer-p) "\
A list of predicate functions run to determine if a buffer is real, unlike
`doom-unreal-buffer-functions'. They are passed one argument: the buffer to be
tested.

Should any of its function returns non-nil, the rest of the functions are
ignored and the buffer is considered real.

See `doom-real-buffer-p' for more information.")

(defvar doom-unreal-buffer-functions '(minibufferp doom-special-buffer-p doom-non-file-visiting-buffer-p) "\
A list of predicate functions run to determine if a buffer is *not* real,
unlike `doom-real-buffer-functions'. They are passed one argument: the buffer to
be tested.

Should any of these functions return non-nil, the rest of the functions are
ignored and the buffer is considered unreal.

See `doom-real-buffer-p' for more information.")

(defvar-local doom-real-buffer-p nil "\
If non-nil, this buffer should be considered real no matter what. See
`doom-real-buffer-p' for more information.")

(defvar doom-fallback-buffer-name "*scratch*" "\
The name of the buffer to fall back to if no other buffers exist (will create
it if it doesn't exist).")

(autoload 'doom-buffer-frame-predicate "/home/maruku/.emacs.d/core/autoload/buffers" "\
To be used as the default frame buffer-predicate parameter. Returns nil if
BUF should be skipped over by functions like `next-buffer' and `other-buffer'.

\(fn BUF)" nil nil)

(autoload 'doom-fallback-buffer "~/.emacs.d/core/autoload/buffers" "\
Returns the fallback buffer, creating it if necessary. By default this is the
scratch buffer. See `doom-fallback-buffer-name' to change this.

\(fn)" nil nil)

(defalias 'doom-buffer-list #'buffer-list)

(autoload 'doom-project-buffer-list "~/.emacs.d/core/autoload/buffers" "\
Return a list of buffers belonging to the current project.

If no project is active, return all buffers.

\(fn)" nil nil)

(autoload 'doom-dired-buffer-p "~/.emacs.d/core/autoload/buffers" "\
Returns non-nil if BUF is a dired buffer.

\(fn BUF)" nil nil)

(autoload 'doom-special-buffer-p "~/.emacs.d/core/autoload/buffers" "\
Returns non-nil if BUF's name starts and ends with an *.

\(fn BUF)" nil nil)

(autoload 'doom-temp-buffer-p "~/.emacs.d/core/autoload/buffers" "\
Returns non-nil if BUF is temporary.

\(fn BUF)" nil nil)

(autoload 'doom-non-file-visiting-buffer-p "~/.emacs.d/core/autoload/buffers" "\
Returns non-nil if BUF does not have a value for `buffer-file-name'.

\(fn BUF)" nil nil)

(autoload 'doom-real-buffer-list "~/.emacs.d/core/autoload/buffers" "\
Return a list of buffers that satify `doom-real-buffer-p'.

\(fn &optional BUFFER-LIST)" nil nil)

(autoload 'doom-real-buffer-p "~/.emacs.d/core/autoload/buffers" "\
Returns t if BUFFER-OR-NAME is a 'real' buffer.

A real buffer is a useful buffer; a first class citizen in Doom. Real ones
should get special treatment, because we will be spending most of our time in
them. Unreal ones should be low-profile and easy to cast aside, so we can focus
on real ones.

The exact criteria for a real buffer is:

  1. A non-nil value for the buffer-local value of the `doom-real-buffer-p'
     variable OR
  2. Any function in `doom-real-buffer-functions' returns non-nil OR
  3. None of the functions in `doom-unreal-buffer-functions' must return
     non-nil.

If BUFFER-OR-NAME is omitted or nil, the current buffer is tested.

\(fn BUFFER-OR-NAME)" nil nil)

(autoload 'doom-unreal-buffer-p "~/.emacs.d/core/autoload/buffers" "\
Return t if BUFFER-OR-NAME is an 'unreal' buffer.

See `doom-real-buffer-p' for details on what that means.

\(fn BUFFER-OR-NAME)" nil nil)

(autoload 'doom-buffers-in-mode "~/.emacs.d/core/autoload/buffers" "\
Return a list of buffers whose `major-mode' is `eq' to MODE(S).

If DERIVED-P, test with `derived-mode-p', otherwise use `eq'.

\(fn MODES &optional BUFFER-LIST DERIVED-P)" nil nil)

(autoload 'doom-visible-windows "~/.emacs.d/core/autoload/buffers" "\
Return a list of the visible, non-popup (dedicated) windows.

\(fn &optional WINDOW-LIST)" nil nil)

(autoload 'doom-visible-buffers "~/.emacs.d/core/autoload/buffers" "\
Return a list of visible buffers (i.e. not buried).

\(fn &optional BUFFER-LIST)" nil nil)

(autoload 'doom-buried-buffers "~/.emacs.d/core/autoload/buffers" "\
Get a list of buffers that are buried.

\(fn &optional BUFFER-LIST)" nil nil)

(autoload 'doom-matching-buffers "~/.emacs.d/core/autoload/buffers" "\
Get a list of all buffers that match the regex PATTERN.

\(fn PATTERN &optional BUFFER-LIST)" nil nil)

(autoload 'doom-set-buffer-real "~/.emacs.d/core/autoload/buffers" "\
Forcibly mark BUFFER as FLAG (non-nil = real).

\(fn BUFFER FLAG)" nil nil)

(autoload 'doom-kill-buffer-and-windows "~/.emacs.d/core/autoload/buffers" "\
Kill the buffer and delete all the windows it's displayed in.

\(fn BUFFER)" nil nil)

(autoload 'doom-kill-matching-buffers "~/.emacs.d/core/autoload/buffers" "\
Kill all buffers (in current workspace OR in BUFFER-LIST) that match the
regex PATTERN. Returns the number of killed buffers.

\(fn PATTERN &optional BUFFER-LIST)" nil nil)

(autoload 'doom|mark-buffer-as-real "~/.emacs.d/core/autoload/buffers" "\
Hook function that marks the current buffer as real.

\(fn)" nil nil)

(autoload 'doom*switch-to-fallback-buffer-maybe "~/.emacs.d/core/autoload/buffers" "\
Advice for `kill-this-buffer'. If in a dedicated window, delete it. If there
are no real buffers left OR if all remaining buffers are visible in other
windows, switch to `doom-fallback-buffer'. Otherwise, delegate to original
`kill-this-buffer'.

\(fn ORIG-FN)" nil nil)

(autoload 'doom/kill-this-buffer-in-all-windows "~/.emacs.d/core/autoload/buffers" "\
Kill BUFFER globally and ensure all windows previously showing this buffer
have switched to a real buffer.

If DONT-SAVE, don't prompt to save modified buffers (discarding their changes).

\(fn BUFFER &optional DONT-SAVE)" t nil)

(autoload 'doom/kill-all-buffers "~/.emacs.d/core/autoload/buffers" "\
Kill all buffers and closes their windows.

If PROJECT-P (universal argument), don't close windows and only kill buffers
that belong to the current project.

\(fn &optional PROJECT-P)" t nil)

(autoload 'doom/kill-other-buffers "~/.emacs.d/core/autoload/buffers" "\
Kill all other buffers (besides the current one).

If PROJECT-P (universal argument), kill only buffers that belong to the current
project.

\(fn &optional PROJECT-P)" t nil)

(autoload 'doom/kill-matching-buffers "~/.emacs.d/core/autoload/buffers" "\
Kill buffers that match PATTERN in BUFFER-LIST.

If PROJECT-P (universal argument), only kill matching buffers in the current
project.

\(fn PATTERN &optional PROJECT-P)" t nil)

(autoload 'doom/kill-buried-buffers "~/.emacs.d/core/autoload/buffers" "\
Kill buffers that are buried.

If PROJECT-P (universal argument), only kill buried buffers belonging to the
current project.

\(fn &optional PROJECT-P)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/completion/company/autoload"
;;;;;;  "modules/completion/company/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/completion/company/autoload.el

(defvar +company-backend-alist '((text-mode :derived (company-dabbrev company-yasnippet company-ispell)) (prog-mode :derived (:separate company-capf company-yasnippet)) (conf-mode :derived company-capf company-dabbrev-code company-yasnippet)) "\
An alist matching modes to company backends. The backends for any mode is
built from this.")

(autoload '+company|init-backends "/home/maruku/.emacs.d/modules/completion/company/autoload" "\
Set `company-backends' for the current buffer.

\(fn)" nil nil)

(autoload '+company-has-completion-p "~/.emacs.d/modules/completion/company/autoload" "\
Return non-nil if a completion candidate exists at point.

\(fn)" nil nil)

(autoload '+company/toggle-auto-completion "~/.emacs.d/modules/completion/company/autoload" "\
Toggle as-you-type code completion.

\(fn)" t nil)

(autoload '+company/complete "~/.emacs.d/modules/completion/company/autoload" "\
Bring up the completion popup. If only one result, complete it.

\(fn)" t nil)

(autoload '+company/dabbrev "~/.emacs.d/modules/completion/company/autoload" "\
Invokes `company-dabbrev-code' in prog-mode buffers and `company-dabbrev'
everywhere else.

\(fn)" t nil)

(autoload '+company/whole-lines "~/.emacs.d/modules/completion/company/autoload" "\
`company-mode' completion backend that completes whole-lines, akin to vim's
C-x C-l.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(autoload '+company/dict-or-keywords "~/.emacs.d/modules/completion/company/autoload" "\
`company-mode' completion combining `company-dict' and `company-keywords'.

\(fn)" t nil)

(autoload '+company/dabbrev-code-previous "~/.emacs.d/modules/completion/company/autoload" "\
TODO

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/completion/helm/autoload/posframe"
;;;;;;  "modules/completion/helm/autoload/posframe.el" (0 0 0 0))
;;; Generated autoloads from modules/completion/helm/autoload/posframe.el

(autoload '+helm-poshandler-frame-center-near-bottom "/home/maruku/.emacs.d/modules/completion/helm/autoload/posframe" "\
Display the child frame in the center of the frame, slightly closer to the
bottom, which is easier on the eyes on big displays.

\(fn INFO)" nil nil)

(autoload '+helm-posframe-display "~/.emacs.d/modules/completion/helm/autoload/posframe" "\
TODO

\(fn BUFFER &optional RESUME)" nil nil)

(autoload '+helm|posframe-cleanup "~/.emacs.d/modules/completion/helm/autoload/posframe" "\
TODO

\(fn)" nil nil)

(autoload '+helm*fix-get-font-height "~/.emacs.d/modules/completion/helm/autoload/posframe" "\


\(fn ORIG-FN POSITION)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/completion/helm/autoload/helm"
;;;;;;  "modules/completion/helm/autoload/helm.el" (0 0 0 0))
;;; Generated autoloads from modules/completion/helm/autoload/helm.el

(autoload '+helm/tasks "/home/maruku/.emacs.d/modules/completion/helm/autoload/helm" "\


\(fn &optional ARG)" t nil)

(autoload '+helm/projectile-find-file "~/.emacs.d/modules/completion/helm/autoload/helm" "\
Call `helm-find-files' if called from HOME, otherwise
`helm-projectile-find-file'.

\(fn)" t nil)

(autoload '+helm/workspace-buffer-list "~/.emacs.d/modules/completion/helm/autoload/helm" "\
A version of `helm-buffers-list' with its buffer list restricted to the
current workspace.

\(fn)" t nil)

(autoload '+helm/workspace-mini "~/.emacs.d/modules/completion/helm/autoload/helm" "\
A version of `helm-mini' with its buffer list restricted to the current
workspace.

\(fn)" t nil)

(autoload '+helm-file-search "~/.emacs.d/modules/completion/helm/autoload/helm" "\
Conduct a file search using ENGINE, which can be any of: rg, ag, pt, and
grep. If omitted, ENGINE will default to the first one it detects, in that
order.

:query STRING
  Determines the initial input to search for.
:in PATH
  Sets what directory to base the search out of. Defaults to the current
  project's root.
:recursive BOOL
  Whether or not to search files recursively from the base directory.

\(fn ENGINE &key QUERY IN ALL-FILES (RECURSIVE t))" nil nil)

(function-put '+helm-file-search 'lisp-indent-function 'defun)

(autoload '+helm/project-search "~/.emacs.d/modules/completion/helm/autoload/helm" "\
Performs a project search from the project root.

Uses the first available search backend from `+helm-project-search-engines'. If
ALL-FILES-P (universal argument), include all files, even hidden or compressed
ones, in the search.

\(fn &optional ARG)" t nil)

(autoload '+helm/project-search-from-cwd "~/.emacs.d/modules/completion/helm/autoload/helm" "\
Performs a project search recursively from the current directory.

Uses the first available search backend from `+helm-project-search-engines'. If
ALL-FILES-P (universal argument), include all files, even hidden or compressed
ones.

\(fn &optional ARG)" t nil)
 (autoload '+helm/rg "/home/maruku/.emacs.d/modules/completion/helm/autoload/helm")
 (autoload '+helm/rg-from-cwd "~/.emacs.d/modules/completion/helm/autoload/helm")
 (autoload '+helm/ag "~/.emacs.d/modules/completion/helm/autoload/helm")
 (autoload '+helm/ag-from-cwd "~/.emacs.d/modules/completion/helm/autoload/helm")
 (autoload '+helm/pt "~/.emacs.d/modules/completion/helm/autoload/helm")
 (autoload '+helm/pt-from-cwd "~/.emacs.d/modules/completion/helm/autoload/helm")
 (autoload '+helm/grep "~/.emacs.d/modules/completion/helm/autoload/helm")
 (autoload '+helm/grep-from-cwd "~/.emacs.d/modules/completion/helm/autoload/helm")

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/completion/helm/autoload/evil"
;;;;;;  "modules/completion/helm/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/completion/helm/autoload/evil.el
 (autoload '+helm:pt "/home/maruku/.emacs.d/modules/completion/helm/autoload/evil" nil t)
 (autoload '+helm:grep "~/.emacs.d/modules/completion/helm/autoload/evil" nil t)
 (autoload '+helm:ag "~/.emacs.d/modules/completion/helm/autoload/evil" nil t)
 (autoload '+helm:rg "~/.emacs.d/modules/completion/helm/autoload/evil" nil t)
 (autoload '+helm:pt-from-cwd "~/.emacs.d/modules/completion/helm/autoload/evil" nil t)
 (autoload '+helm:grep-from-cwd "~/.emacs.d/modules/completion/helm/autoload/evil" nil t)
 (autoload '+helm:ag-from-cwd "~/.emacs.d/modules/completion/helm/autoload/evil" nil t)
 (autoload '+helm:rg-from-cwd "~/.emacs.d/modules/completion/helm/autoload/evil" nil t)

(autoload '+helm--set-prompt-display "/home/maruku/.emacs.d/modules/completion/helm/autoload/evil" "\
TODO

\(fn POS)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/completion/ivy/autoload/ivy"
;;;;;;  "modules/completion/ivy/autoload/ivy.el" (0 0 0 0))
;;; Generated autoloads from modules/completion/ivy/autoload/ivy.el

(autoload '+ivy-rich-buffer-name "/home/maruku/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Display the buffer name.

Displays buffers in other projects in `font-lock-doc-face', and
temporary/special buffers in `font-lock-comment-face'.

\(fn CANDIDATE)" nil nil)

(autoload '+ivy/switch-workspace-buffer "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Switch to another buffer within the current workspace.

If ARG (universal argument), open selection in other-window.

\(fn &optional ARG)" t nil)

(autoload '+ivy/switch-workspace-buffer-other-window "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Switch another window to a buffer within the current workspace.

\(fn)" t nil)

(autoload '+ivy/switch-buffer "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Switch to another buffer.

\(fn)" t nil)

(autoload '+ivy/switch-buffer-other-window "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Switch to another buffer in another window.

\(fn)" t nil)

(autoload '+ivy/tasks "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Search through all TODO/FIXME tags in the current project. If ARG, only
search current file. See `+ivy-task-tags' to customize what this searches for.

\(fn &optional ARG)" t nil)

(autoload '+ivy/wgrep-occur "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Invoke the search+replace wgrep buffer on the current ag/rg search results.

\(fn)" t nil)

(autoload '+ivy-yas-prompt "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\


\(fn PROMPT CHOICES &optional DISPLAY-FN)" nil nil)

(autoload '+ivy-git-grep-other-window-action "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Opens the current candidate in another window.

\(fn X)" nil nil)

(autoload '+ivy-confirm-delete-file "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\


\(fn X)" nil nil)

(autoload '+ivy/projectile-find-file "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
A more sensible `counsel-projectile-find-file', which will revert to
`counsel-find-file' if invoked from $HOME, `counsel-file-jump' if invoked from a
non-project, `projectile-find-file' if in a big project (more than
`ivy-sort-max-size' files), or `counsel-projectile-find-file' otherwise.

The point of this is to avoid Emacs locking up indexing massive file trees.

\(fn)" t nil)

(autoload '+ivy-file-search "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Conduct a file search using ENGINE, which can be any of: rg, ag, pt, and
grep. If omitted, ENGINE will default to the first one it detects, in that
order.

:query STRING
  Determines the initial input to search for.
:in PATH
  Sets what directory to base the search out of. Defaults to the current
  project's root.
:recursive BOOL
  Whether or not to search files recursively from the base directory.

\(fn ENGINE &key QUERY IN ALL-FILES (RECURSIVE t))" nil nil)

(function-put '+ivy-file-search 'lisp-indent-function 'defun)

(autoload '+ivy/project-search "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Performs a project search from the project root.

Uses the first available search backend from `+ivy-project-search-engines'. If
ALL-FILES-P (universal argument), include all files, even hidden or compressed
ones, in the search.

\(fn &optional ALL-FILES-P)" t nil)

(autoload '+ivy/project-search-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/ivy" "\
Performs a project search recursively from the current directory.

Uses the first available search backend from `+ivy-project-search-engines'. If
ALL-FILES-P (universal argument), include all files, even hidden or compressed
ones.

\(fn &optional ALL-FILES-P)" t nil)
 (autoload '+ivy/rg "/home/maruku/.emacs.d/modules/completion/ivy/autoload/ivy")
 (autoload '+ivy/rg-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/ivy")
 (autoload '+ivy/ag "~/.emacs.d/modules/completion/ivy/autoload/ivy")
 (autoload '+ivy/ag-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/ivy")
 (autoload '+ivy/pt "~/.emacs.d/modules/completion/ivy/autoload/ivy")
 (autoload '+ivy/pt-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/ivy")
 (autoload '+ivy/grep "~/.emacs.d/modules/completion/ivy/autoload/ivy")
 (autoload '+ivy/grep-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/ivy")

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/completion/ivy/autoload/hydras"
;;;;;;  "modules/completion/ivy/autoload/hydras.el" (0 0 0 0))
;;; Generated autoloads from modules/completion/ivy/autoload/hydras.el
 (autoload '+ivy-coo-hydra/body "/home/maruku/.emacs.d/modules/completion/ivy/autoload/hydras" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/completion/ivy/autoload/evil"
;;;;;;  "modules/completion/ivy/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/completion/ivy/autoload/evil.el
 (autoload '+ivy:swiper "/home/maruku/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:todo "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:pt "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:grep "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:ag "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:rg "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:pt-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:grep-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:ag-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)
 (autoload '+ivy:rg-from-cwd "~/.emacs.d/modules/completion/ivy/autoload/evil" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/config/default/autoload/default"
;;;;;;  "modules/config/default/autoload/default.el" (0 0 0 0))
;;; Generated autoloads from modules/config/default/autoload/default.el

(autoload '+default/yank-buffer-filename "/home/maruku/.emacs.d/modules/config/default/autoload/default" "\
Copy the current buffer's path to the kill ring.

\(fn)" t nil)

(autoload '+default/browse-project "~/.emacs.d/modules/config/default/autoload/default" "\


\(fn)" t nil)

(autoload '+default/browse-templates "~/.emacs.d/modules/config/default/autoload/default" "\


\(fn)" t nil)

(autoload '+default/find-in-templates "~/.emacs.d/modules/config/default/autoload/default" "\


\(fn)" t nil)

(autoload '+default/browse-emacsd "~/.emacs.d/modules/config/default/autoload/default" "\


\(fn)" t nil)

(autoload '+default/find-in-emacsd "~/.emacs.d/modules/config/default/autoload/default" "\


\(fn)" t nil)

(autoload '+default/browse-notes "~/.emacs.d/modules/config/default/autoload/default" "\


\(fn)" t nil)

(autoload '+default/find-in-notes "~/.emacs.d/modules/config/default/autoload/default" "\


\(fn)" t nil)

(autoload '+default/compile "~/.emacs.d/modules/config/default/autoload/default" "\
Runs `compile' from the root of the current project.

If a compilation window is already open, recompile that instead.

If ARG (universal argument), runs `compile' from the current directory.

\(fn ARG)" t nil)

(autoload '+default/man-or-woman "~/.emacs.d/modules/config/default/autoload/default" "\
Invoke `man' if man is installed, otherwise use `woman'.

\(fn)" t nil)

(defalias '+default/newline #'newline)

(autoload '+default/new-buffer "~/.emacs.d/modules/config/default/autoload/default" "\
TODO

\(fn)" t nil)

(autoload '+default/project-tasks "~/.emacs.d/modules/config/default/autoload/default" "\
Invokes `+ivy/tasks' or `+helm/tasks', depending on which is available.

\(fn)" t nil)

(autoload '+default/newline-above "~/.emacs.d/modules/config/default/autoload/default" "\
Insert an indented new line before the current one.

\(fn)" t nil)

(autoload '+default/newline-below "~/.emacs.d/modules/config/default/autoload/default" "\
Insert an indented new line after the current one.

\(fn)" t nil)

(autoload '+default/yank-pop "~/.emacs.d/modules/config/default/autoload/default" "\
Interactively select what text to insert from the kill ring.

\(fn)" t nil)

(autoload '+default*newline-indent-and-continue-comments "~/.emacs.d/modules/config/default/autoload/default" "\
Inserts a newline and possibly indents it. Also continues comments if
executed from a commented line; handling special cases for certain languages
with weak native support.

\(fn ORIG-FN)" t nil)

(autoload '+default*delete-backward-char "~/.emacs.d/modules/config/default/autoload/default" "\
Same as `delete-backward-char', but preforms these additional checks:

+ If point is surrounded by (balanced) whitespace and a brace delimiter ({} []
  ()), delete a space on either side of the cursor.
+ If point is at BOL and surrounded by braces on adjacent lines, collapse
  newlines:
  {
  |
  } => {|}
+ Otherwise, resort to `doom--backward-delete-whitespace-to-column'.
+ Resorts to `delete-char' if n > 1

\(fn N &optional KILLFLAG)" t nil)

(autoload '+default/search-from-cwd "~/.emacs.d/modules/config/default/autoload/default" "\
Conduct a text search in files under the current folder.
If prefix ARG is set, prompt for a directory to search from.

\(fn &optional ARG)" t nil)

(autoload '+default/search-project "~/.emacs.d/modules/config/default/autoload/default" "\
Conduct a text search in files under the project root.
If prefix ARG is set, prompt for a project to search from.

\(fn &optional ARG)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/editor/fold/autoload/fold"
;;;;;;  "modules/editor/fold/autoload/fold.el" (0 0 0 0))
;;; Generated autoloads from modules/editor/fold/autoload/fold.el

(autoload '+fold-hideshow*ensure-mode "/home/maruku/.emacs.d/modules/editor/fold/autoload/fold" "\
Ensure hs-minor-mode is enabled.

\(fn &rest _)" nil nil)

(autoload '+fold-hideshow-haml-forward-sexp "~/.emacs.d/modules/editor/fold/autoload/fold" "\


\(fn ARG)" nil nil)

(autoload '+fold-hideshow-forward-block-by-indent "~/.emacs.d/modules/editor/fold/autoload/fold" "\


\(fn ARG)" nil nil)

(autoload '+fold-hideshow-set-up-overlay "~/.emacs.d/modules/editor/fold/autoload/fold" "\


\(fn OV)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/editor/fold/autoload/evil"
;;;;;;  "modules/editor/fold/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/editor/fold/autoload/evil.el

(autoload '+fold/toggle "/home/maruku/.emacs.d/modules/editor/fold/autoload/evil" "\
Toggle the fold at point.

Targets `vimmish-fold', `hideshow' and `outline' folds.

\(fn)" t nil)

(autoload '+fold/open "~/.emacs.d/modules/editor/fold/autoload/evil" "\
Open the folded region at point.

Targets `vimmish-fold', `hideshow' and `outline' folds.

\(fn)" t nil)

(autoload '+fold/close "~/.emacs.d/modules/editor/fold/autoload/evil" "\
Close the folded region at point.

Targets `vimmish-fold', `hideshow' and `outline' folds.

\(fn)" t nil)

(autoload '+fold/open-all "~/.emacs.d/modules/editor/fold/autoload/evil" "\
Open folds at LEVEL (or all folds if LEVEL is nil).

\(fn &optional LEVEL)" t nil)

(autoload '+fold/close-all "~/.emacs.d/modules/editor/fold/autoload/evil" "\
Close folds at LEVEL (or all folds if LEVEL is nil).

\(fn &optional LEVEL)" t nil)

(autoload '+fold/next "~/.emacs.d/modules/editor/fold/autoload/evil" "\
Jump to the next vimish fold, outline heading or folded region.

\(fn COUNT)" t nil)

(autoload '+fold/previous "~/.emacs.d/modules/editor/fold/autoload/evil" "\
Jump to the previous vimish fold, outline heading or folded region.

\(fn COUNT)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/editor/multiple-cursors/autoload/evil-mc"
;;;;;;  "modules/editor/multiple-cursors/autoload/evil-mc.el" (0
;;;;;;  0 0 0))
;;; Generated autoloads from modules/editor/multiple-cursors/autoload/evil-mc.el

(autoload '+multiple-cursors/evil-mc-toggle-cursors "/home/maruku/.emacs.d/modules/editor/multiple-cursors/autoload/evil-mc" "\
Toggle frozen state of evil-mc cursors.

\(fn)" t nil)
 (autoload '+multiple-cursors/evil-mc-make-cursor-here "/home/maruku/.emacs.d/modules/editor/multiple-cursors/autoload/evil-mc" nil t)
 (autoload '+multiple-cursors:evil-mc "~/.emacs.d/modules/editor/multiple-cursors/autoload/evil-mc" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/editor/rotate-text/autoload"
;;;;;;  "modules/editor/rotate-text/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/editor/rotate-text/autoload.el

(after! rotate-text (add-to-list 'rotate-text-words '("true" "false")))

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/emacs/vc/autoload/vc"
;;;;;;  "modules/emacs/vc/autoload/vc.el" (0 0 0 0))
;;; Generated autoloads from modules/emacs/vc/autoload/vc.el

(autoload '+vc-git-root-url "/home/maruku/.emacs.d/modules/emacs/vc/autoload/vc" "\
Return the root git repo URL for the current file.

\(fn)" nil nil)

(autoload '+vc/git-browse-region-or-line "~/.emacs.d/modules/emacs/vc/autoload/vc" "\
Open the website for the current version controlled file. Fallback to
repository root.

\(fn &optional ARG)" t nil)

(autoload '+vc*update-header-line "~/.emacs.d/modules/emacs/vc/autoload/vc" "\
Show revision details in the header-line, instead of the minibuffer.

Sometimes I forget `git-timemachine' is enabled in a buffer. Putting revision
info in the `header-line-format' is a good indication.

\(fn REVISION)" nil nil)
 (autoload '+vc-smerge-hydra/body "emacs/vc/autoload" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/emacs/vc/autoload/evil"
;;;;;;  "modules/emacs/vc/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/emacs/vc/autoload/evil.el
 (autoload '+vc:git-browse "/home/maruku/.emacs.d/modules/emacs/vc/autoload/evil" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/eval/autoload/settings"
;;;;;;  "modules/feature/eval/autoload/settings.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/eval/autoload/settings.el

(defvar +eval-repls nil "\
An alist mapping major modes to plists that describe REPLs. Used by
`+eval/open-repl-other-window' and filled with the `:repl' setting.")

(defvar +eval-runners nil "\
Alist mapping major modes to interactive runner functions.")

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/eval/autoload/repl"
;;;;;;  "modules/feature/eval/autoload/repl.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/eval/autoload/repl.el

(autoload '+eval/open-repl-same-window "/home/maruku/.emacs.d/modules/feature/eval/autoload/repl" "\
Opens (or reopens) the REPL associated with the current major-mode and place
the cursor at the prompt.

If ARG (universal argument), prompt for a specific REPL to open.

\(fn &optional ARG)" t nil)

(autoload '+eval/open-repl-other-window "~/.emacs.d/modules/feature/eval/autoload/repl" "\
Does `+eval/open-repl', but in a popup window.

If ARG (universal argument), prompt for a specific REPL to open.

\(fn &optional ARG)" t nil)

(autoload '+eval/send-region-to-repl "~/.emacs.d/modules/feature/eval/autoload/repl" "\
REPL must be open! Sends a selected region to it. If AUTO-EXECUTE-P, then
execute it immediately after.

\(fn BEG END &optional AUTO-EXECUTE-P)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/eval/autoload/evil"
;;;;;;  "modules/feature/eval/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/eval/autoload/evil.el
 (autoload '+eval:region "/home/maruku/.emacs.d/modules/feature/eval/autoload/evil" nil t)
 (autoload '+eval:replace-region "~/.emacs.d/modules/feature/eval/autoload/evil" nil t)
 (autoload '+eval:repl "~/.emacs.d/modules/feature/eval/autoload/evil" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/eval/autoload/eval"
;;;;;;  "modules/feature/eval/autoload/eval.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/eval/autoload/eval.el

(autoload '+eval/buffer "/home/maruku/.emacs.d/modules/feature/eval/autoload/eval" "\
Evaluate the whole buffer.

\(fn)" t nil)

(autoload '+eval/region "~/.emacs.d/modules/feature/eval/autoload/eval" "\
Evaluate a region between BEG and END and display the output.

\(fn BEG END)" t nil)

(autoload '+eval/line-or-region "~/.emacs.d/modules/feature/eval/autoload/eval" "\
Evaluate the current line or selected region.

\(fn)" t nil)

(autoload '+eval/buffer-or-region "~/.emacs.d/modules/feature/eval/autoload/eval" "\
Evaluate the whole buffer.

\(fn)" t nil)

(autoload '+eval/region-and-replace "~/.emacs.d/modules/feature/eval/autoload/eval" "\
Evaluation a region between BEG and END, and replace it with the result.

\(fn BEG END)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/evil/autoload/files"
;;;;;;  "modules/feature/evil/autoload/files.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/evil/autoload/files.el
 (autoload '+evil:delete-this-file "/home/maruku/.emacs.d/modules/feature/evil/autoload/files" nil t)
 (autoload '+evil:move-this-file "~/.emacs.d/modules/feature/evil/autoload/files" nil t)
 (autoload '+evil:copy-this-file "~/.emacs.d/modules/feature/evil/autoload/files" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/evil/autoload/evil"
;;;;;;  "modules/feature/evil/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/evil/autoload/evil.el

(autoload '+evil/visual-indent "/home/maruku/.emacs.d/modules/feature/evil/autoload/evil" "\
vnoremap < <gv

\(fn)" t nil)

(autoload '+evil/visual-dedent "~/.emacs.d/modules/feature/evil/autoload/evil" "\
vnoremap > >gv

\(fn)" t nil)

(autoload '+evil/reselect-paste "~/.emacs.d/modules/feature/evil/autoload/evil" "\
Return to visual mode and reselect the last pasted region.

\(fn)" t nil)

(autoload '+evil/paste-preserve-register "~/.emacs.d/modules/feature/evil/autoload/evil" "\
Call `evil-paste-after' without overwriting the clipboard (by writing to the
0 register instead). This allows you to paste the same text again afterwards.

\(fn)" t nil)

(autoload '+evil/window-move-left "~/.emacs.d/modules/feature/evil/autoload/evil" "\
See `+evil--window-swap'

\(fn)" t nil)

(autoload '+evil/window-move-right "~/.emacs.d/modules/feature/evil/autoload/evil" "\
See `+evil--window-swap'

\(fn)" t nil)

(autoload '+evil/window-move-up "~/.emacs.d/modules/feature/evil/autoload/evil" "\
See `+evil--window-swap'

\(fn)" t nil)

(autoload '+evil/window-move-down "~/.emacs.d/modules/feature/evil/autoload/evil" "\
See `+evil--window-swap'

\(fn)" t nil)

(autoload '+evil/easymotion "~/.emacs.d/modules/feature/evil/autoload/evil" "\
Invoke and lazy-load `evil-easymotion' without compromising which-key
integration.

\(fn)" t nil)
 (autoload '+evil:apply-macro "/home/maruku/.emacs.d/modules/feature/evil/autoload/evil" nil t)
 (autoload '+evil:retab "~/.emacs.d/modules/feature/evil/autoload/evil" nil t)
 (autoload '+evil:narrow-buffer "~/.emacs.d/modules/feature/evil/autoload/evil" nil t)

(autoload '+evil-ex-buffer-match "~/.emacs.d/modules/feature/evil/autoload/evil" "\


\(fn FLAG &optional ARG)" nil nil)

(autoload '+evil-ex-global-match "~/.emacs.d/modules/feature/evil/autoload/evil" "\


\(fn FLAG &optional ARG)" nil nil)

(autoload '+evil-ex-global-delim-match "~/.emacs.d/modules/feature/evil/autoload/evil" "\


\(fn FLAG &optional ARG)" nil nil)
 (autoload '+evil:align "~/.emacs.d/modules/feature/evil/autoload/evil" nil t)
 (autoload '+evil:align-right "~/.emacs.d/modules/feature/evil/autoload/evil" nil t)
 (autoload '+evil-delete "~/.emacs.d/modules/feature/evil/autoload/evil" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/evil/autoload/embrace"
;;;;;;  "modules/feature/evil/autoload/embrace.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/evil/autoload/embrace.el

(autoload '+evil--embrace-get-pair "/home/maruku/.emacs.d/modules/feature/evil/autoload/embrace" "\


\(fn CHAR)" nil nil)

(autoload '+evil--embrace-escaped "~/.emacs.d/modules/feature/evil/autoload/embrace" "\
Backslash-escaped surround character support for embrace.

\(fn)" nil nil)

(autoload '+evil--embrace-latex "~/.emacs.d/modules/feature/evil/autoload/embrace" "\
LaTeX command support for embrace.

\(fn)" nil nil)

(autoload '+evil--embrace-elisp-fn "~/.emacs.d/modules/feature/evil/autoload/embrace" "\
Elisp function support for embrace.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/evil/autoload/advice"
;;;;;;  "modules/feature/evil/autoload/advice.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/evil/autoload/advice.el

(autoload '+evil*insert-newline-below-and-respect-comments "/home/maruku/.emacs.d/modules/feature/evil/autoload/advice" "\


\(fn ORIG-FN COUNT)" nil nil)

(autoload '+evil*insert-newline-above-and-respect-comments "~/.emacs.d/modules/feature/evil/autoload/advice" "\


\(fn ORIG-FN COUNT)" nil nil)

(autoload '+evil*static-reindent "~/.emacs.d/modules/feature/evil/autoload/advice" "\
Don't move cursor on indent.

\(fn ORIG-FN &rest ARGS)" nil nil)

(autoload '+evil*resolve-vim-path "~/.emacs.d/modules/feature/evil/autoload/advice" "\
Take a path and resolve any vim-like filename modifiers in it. This adds
support for most vim file modifiers, as well as:

  %:P   Resolves to `doom-project-root'.

See http://vimdoc.sourceforge.net/htmldoc/cmdline.html#filename-modifiers for
more information on modifiers.

\(fn FILE-NAME)" nil nil)
 (autoload '+evil*window-split "/home/maruku/.emacs.d/modules/feature/evil/autoload/advice" nil t)
 (autoload '+evil*window-vsplit "~/.emacs.d/modules/feature/evil/autoload/advice" nil t)

(autoload '+evil*escape "~/.emacs.d/modules/feature/evil/autoload/advice" "\
Call `doom/escape' if `evil-force-normal-state' is called interactively.

\(fn &rest _)" nil nil)

(autoload '+evil*make-numbered-markers-global "~/.emacs.d/modules/feature/evil/autoload/advice" "\


\(fn ORIG-FN CHAR)" nil nil)

(autoload '+evil*set-jump "~/.emacs.d/modules/feature/evil/autoload/advice" "\
Set a jump point and ensure ORIG-FN doesn't set any new jump points.

\(fn ORIG-FN &rest ARGS)" nil nil)

(autoload '+evil*fix-dabbrev-in-minibuffer "~/.emacs.d/modules/feature/evil/autoload/advice" "\
Make `try-expand-dabbrev' from `hippie-expand' work in minibuffer. See
`he-dabbrev-beg', so we need to redefine syntax for '/'.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/file-templates/autoload"
;;;;;;  "modules/feature/file-templates/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/file-templates/autoload.el

(autoload '+file-templates--expand "/home/maruku/.emacs.d/modules/feature/file-templates/autoload" "\
Auto insert a yasnippet snippet into current file and enter insert mode (if
evil is loaded and enabled).

\(fn PRED &key PROJECT MODE TRIGGER IGNORE WHEN)" nil nil)

(autoload '+file-templates-get-short-path "~/.emacs.d/modules/feature/file-templates/autoload" "\
Fetches a short file path for the header in Doom module templates.

\(fn)" nil nil)

(autoload '+file-template-p "~/.emacs.d/modules/feature/file-templates/autoload" "\
Return t if RULE applies to the current buffer.

\(fn RULE)" nil nil)

(autoload '+file-templates/insert-license "~/.emacs.d/modules/feature/file-templates/autoload" "\
Insert a license file template into the current file.

\(fn)" t nil)

(autoload '+file-templates/debug "~/.emacs.d/modules/feature/file-templates/autoload" "\
Tests the current buffer and outputs the file template rule most appropriate
for it. This is used for testing.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/lookup/autoload/lookup"
;;;;;;  "modules/feature/lookup/autoload/lookup.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/lookup/autoload/lookup.el

(autoload '+lookup/definition "/home/maruku/.emacs.d/modules/feature/lookup/autoload/lookup" "\
Jump to the definition of IDENTIFIER (defaults to the symbol at point).

If OTHER-WINDOW (universal argument), open the result in another window.

Each function in `+lookup-definition-functions' is tried until one changes the
point or current buffer. Falls back to dumb-jump, naive
ripgrep/the_silver_searcher text search, then `evil-goto-definition' if
evil-mode is active.

\(fn IDENTIFIER &optional OTHER-WINDOW)" t nil)

(autoload '+lookup/references "~/.emacs.d/modules/feature/lookup/autoload/lookup" "\
Show a list of usages of IDENTIFIER (defaults to the symbol at point)

Tries each function in `+lookup-references-functions' until one changes the
point and/or current buffer. Falls back to a naive ripgrep/the_silver_searcher
search otherwise.

\(fn IDENTIFIER &optional OTHER-WINDOW)" t nil)

(autoload '+lookup/documentation "~/.emacs.d/modules/feature/lookup/autoload/lookup" "\
Show documentation for IDENTIFIER (defaults to symbol at point or selection.

First attempts the :documentation handler specified with `set-lookup-handlers!'
for the current mode/buffer (if any), then falls back to the backends in
`+lookup-documentation-functions'.

\(fn IDENTIFIER &optional ARG)" t nil)

(autoload '+lookup/file "~/.emacs.d/modules/feature/lookup/autoload/lookup" "\
Figure out PATH from whatever is at point and open it.

Each function in `+lookup-file-functions' is tried until one changes the point
or the current buffer.

Otherwise, falls back on `find-file-at-point'.

\(fn PATH)" t nil)

(autoload '+lookup/in-docsets "~/.emacs.d/modules/feature/lookup/autoload/lookup" "\
Looks up QUERY (a string) in available Dash docsets for the current buffer.

DOCSETS is a list of docset strings. Docsets can be installed with
`+lookup/install-docset'.

\(fn &optional QUERY DOCSETS)" t nil)

(autoload '+lookup/online "~/.emacs.d/modules/feature/lookup/autoload/lookup" "\
Looks up SEARCH (a string) in you browser using PROVIDER.

PROVIDER should be a key of `+lookup-provider-url-alist'.

When used interactively, it will prompt for a query and, for the first time, the
provider from `+lookup-provider-url-alist'. On consecutive uses, the last
provider will be reused. If the universal argument is supplied, always prompt
for the provider.

\(fn SEARCH &optional PROVIDER)" t nil)

(autoload '+lookup/online-select "~/.emacs.d/modules/feature/lookup/autoload/lookup" "\
Runs `+lookup/online', but always prompts for the provider to use.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/lookup/autoload/evil"
;;;;;;  "modules/feature/lookup/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/lookup/autoload/evil.el
 (autoload '+lookup:online "/home/maruku/.emacs.d/modules/feature/lookup/autoload/evil" nil t)
 (autoload '+lookup:dash "~/.emacs.d/modules/feature/lookup/autoload/evil" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/lookup/autoload/docsets"
;;;;;;  "modules/feature/lookup/autoload/docsets.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/lookup/autoload/docsets.el

(autoload '+lookup-docsets-for-buffer "/home/maruku/.emacs.d/modules/feature/lookup/autoload/docsets" "\
Return list of installed & selected docsets for the current major mode.

This list is built from `+lookup-docset-alist'.

\(fn)" nil nil)

(autoload '+lookup-docset-installed-p "~/.emacs.d/modules/feature/lookup/autoload/docsets" "\
Return t if DOCSET is installed.

\(fn DOCSET)" nil nil)

(autoload 'helm-dash-installed-docsets "/home/maruku/.emacs.d/.local/packages/elpa/helm-dash-20190316.2009/helm-dash")

(autoload 'helm-dash-docset-installed-p "~/.emacs.d/.local/packages/elpa/helm-dash-20190316.2009/helm-dash")

(defalias '+lookup/install-docset #'helm-dash-install-docset)

(autoload '+lookup/in-docsets "~/.emacs.d/modules/feature/lookup/autoload/docsets" "\
Lookup QUERY in dash DOCSETS.

QUERY is a string and docsets in an array of strings, each a name of a Dash
docset. Requires either helm or ivy.

Use `+lookup/install-docset' to install docsets.

\(fn &optional QUERY DOCSETS)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/snippets/autoload/snippets"
;;;;;;  "modules/feature/snippets/autoload/snippets.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/snippets/autoload/snippets.el

(autoload '+snippets-prompt-private "/home/maruku/.emacs.d/modules/feature/snippets/autoload/snippets" "\
Prioritize private snippets over built-in ones if there are multiple
choices.

There are two groups of snippets in Doom Emacs. The built in ones (under
`doom-emacs-dir'; provided by Doom or its plugins) or your private snippets
\(outside of `doom-eamcs-dir').

If there are multiple snippets with the same key in either camp (but not both),
you will be prompted to select one.

If there are conflicting keys across the two camps, the built-in ones are
ignored. This makes it easy to override built-in snippets with private ones.

\(fn PROMPT CHOICES &optional DISPLAY-FN)" nil nil)

(autoload '+snippets/goto-start-of-field "~/.emacs.d/modules/feature/snippets/autoload/snippets" "\
Go to the beginning of the current field.

\(fn)" t nil)

(autoload '+snippets/goto-end-of-field "~/.emacs.d/modules/feature/snippets/autoload/snippets" "\
Go to the end of the current field.

\(fn)" t nil)

(autoload '+snippets/delete-backward-char "~/.emacs.d/modules/feature/snippets/autoload/snippets" "\
Prevents Yas from interfering with backspace deletion.

\(fn &optional FIELD)" t nil)

(autoload '+snippets/delete-forward-char-or-field "~/.emacs.d/modules/feature/snippets/autoload/snippets" "\
Delete forward, or skip the current field if it's empty. This is to prevent
buggy behavior when <delete> is pressed in an empty field.

\(fn &optional FIELD)" t nil)

(autoload '+snippets/delete-to-start-of-field "~/.emacs.d/modules/feature/snippets/autoload/snippets" "\
Delete to start-of-field.

\(fn &optional FIELD)" t nil)

(autoload '+snippets|enable-project-modes "~/.emacs.d/modules/feature/snippets/autoload/snippets" "\
Automatically enable snippet libraries for project minor modes defined with
`def-project-mode!'.

\(fn MODE &rest _)" nil nil)

(autoload '+snippets/browse "~/.emacs.d/modules/feature/snippets/autoload/snippets" "\
TODO

\(fn ARG)" t nil)

(autoload '+snippets/find-file "~/.emacs.d/modules/feature/snippets/autoload/snippets" "\
TODO

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/snippets/autoload/evil"
;;;;;;  "modules/feature/snippets/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/snippets/autoload/evil.el

(autoload '+snippets/expand-on-region "/home/maruku/.emacs.d/modules/feature/snippets/autoload/evil" "\
Only use this with `evil-mode'. Expands a snippet around a selected region
and switches to insert mode if there are editable fields.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/workspaces/autoload/workspaces"
;;;;;;  "modules/feature/workspaces/autoload/workspaces.el" (0 0
;;;;;;  0 0))
;;; Generated autoloads from modules/feature/workspaces/autoload/workspaces.el

(defface +workspace-tab-selected-face '((t (:inherit highlight))) "\
The face for selected tabs displayed by `+workspace/display'" :group (quote persp-mode))

(defface +workspace-tab-face '((t (:inherit default))) "\
The face for selected tabs displayed by `+workspace/display'" :group (quote persp-mode))

(defalias #'+workspace-p #'perspective-p "\
Return t if OBJ is a perspective hash table.")

(autoload '+workspace-exists-p "/home/maruku/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Returns t if NAME is the name of an existing workspace.

\(fn NAME)" nil nil)

(defalias #'+workspace-contains-buffer-p #'persp-contain-buffer-p "\
Return non-nil if BUFFER is in WORKSPACE (defaults to current workspace).")

(defalias #'+workspace-current #'get-current-persp "\
Return the currently active workspace.")

(autoload '+workspace-get "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Return a workspace named NAME. Unless NOERROR is non-nil, this throws an
error if NAME doesn't exist.

\(fn NAME &optional NOERROR)" nil nil)

(autoload '+workspace-current-name "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Get the name of the current workspace.

\(fn)" nil nil)

(autoload '+workspace-list "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Return a list of workspace structs (satisifes `+workspace-p').

\(fn)" nil nil)

(autoload '+workspace-list-names "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Return the list of names of open workspaces.

\(fn)" nil nil)

(autoload '+workspace-buffer-list "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Return a list of buffers in PERSP.

The buffer list is ordered by recency (same as `buffer-list').

PERSP can be a string (name of a workspace) or a workspace (satisfies
`+workspace-p'). If nil or omitted, it defaults to the current workspace.

\(fn &optional PERSP)" nil nil)

(autoload '+workspace-orphaned-buffer-list "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Return a list of buffers that aren't associated with any perspective.

\(fn)" nil nil)

(autoload '+workspace-load "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Loads a single workspace (named NAME) into the current session. Can only
retrieve perspectives that were explicitly saved with `+workspace-save'.

Returns t if successful, nil otherwise.

\(fn NAME)" nil nil)

(autoload '+workspace-save "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Saves a single workspace (NAME) from the current session. Can be loaded again
with `+workspace-load'. NAME can be the string name of a workspace or its
perspective hash table.

Returns t on success, nil otherwise.

\(fn NAME)" nil nil)

(autoload '+workspace-new "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Create a new workspace named NAME. If one already exists, return nil.
Otherwise return t on success, nil otherwise.

\(fn NAME)" nil nil)

(autoload '+workspace-rename "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Rename the current workspace named NAME to NEW-NAME. Returns old name on
success, nil otherwise.

\(fn NAME NEW-NAME)" nil nil)

(autoload '+workspace-delete "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Delete the workspace denoted by WORKSPACE, which can be the name of a perspective
or its hash table. If INHIBIT-KILL-P is non-nil, don't kill this workspace's
buffers.

\(fn WORKSPACE &optional INHIBIT-KILL-P)" nil nil)

(autoload '+workspace-switch "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Switch to another workspace named NAME (a string).

If AUTO-CREATE-P is non-nil, create the workspace if it doesn't exist, otherwise
throws an error.

\(fn NAME &optional AUTO-CREATE-P)" nil nil)

(defalias '+workspace/restore-last-session #'doom/quickload-session)

(autoload '+workspace/load "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Load a workspace and switch to it. If called with C-u, try to reload the
current workspace (by name) from session files.

\(fn NAME)" t nil)

(autoload '+workspace/save "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Save the current workspace. If called with C-u, autosave the current
workspace.

\(fn NAME)" t nil)

(autoload '+workspace/rename "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Rename the current workspace.

\(fn NEW-NAME)" t nil)

(autoload '+workspace/delete "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Delete this workspace. If called with C-u, prompts you for the name of the
workspace to delete.

\(fn NAME)" t nil)

(autoload '+workspace/kill-session "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Delete the current session, all workspaces, windows and their buffers.

\(fn)" t nil)

(autoload '+workspace/kill-session-and-quit "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Kill emacs without saving anything.

\(fn)" t nil)

(autoload '+workspace/new "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Create a new workspace named NAME. If CLONE-P is non-nil, clone the current
workspace, otherwise the new workspace is blank.

\(fn &optional NAME CLONE-P)" t nil)

(autoload '+workspace/switch-to "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Switch to a workspace at a given INDEX. A negative number will start from the
end of the workspace list.

\(fn INDEX)" t nil)

(autoload '+workspace/switch-to-last "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Switch to the last workspace.

\(fn)" t nil)

(autoload '+workspace/cycle "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Cycle n workspaces to the right (default) or left.

\(fn N)" t nil)

(autoload '+workspace/switch-left "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\


\(fn)" t nil)

(autoload '+workspace/switch-right "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\


\(fn)" t nil)

(autoload '+workspace/close-window-or-workspace "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Close the selected window. If it's the last window in the workspace, either
close the workspace (as well as its associated frame, if one exists) and move to
the next.

\(fn)" t nil)

(autoload '+workspace-message "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Show an 'elegant' message in the echo area next to a listing of workspaces.

\(fn MESSAGE &optional TYPE)" nil nil)

(autoload '+workspace-error "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Show an 'elegant' error in the echo area next to a listing of workspaces.

\(fn MESSAGE &optional NOERROR)" nil nil)

(autoload '+workspace/display "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Display a list of workspaces (like tabs) in the echo area.

\(fn)" t nil)

(autoload '+workspaces|delete-associated-workspace "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Delete workspace associated with current frame.
A workspace gets associated with a frame when a new frame is interactively
created.

\(fn &optional FRAME)" nil nil)

(autoload '+workspaces|cleanup-unassociated-buffers "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Kill leftover buffers that are unassociated with any perspective.

\(fn)" nil nil)

(autoload '+workspaces|associate-frame "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Create a blank, new perspective and associate it with FRAME.

\(fn FRAME &optional NEW-FRAME-P)" nil nil)

(autoload '+workspaces|set-project-action "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
A `projectile-switch-project-action' that sets the project directory for
`+workspaces|switch-to-project'.

\(fn)" nil nil)

(autoload '+workspaces|switch-to-project "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Creates a workspace dedicated to a new project. If one already exists, switch
to it. If in the main workspace and it's empty, recycle that workspace, without
renaming it.

Afterwords, runs `+workspaces-switch-project-function'. By default, this prompts
the user to open a file in the new project.

This be hooked to `projectile-after-switch-project-hook'.

\(fn &optional DIR)" nil nil)

(autoload '+workspaces*autosave-real-buffers "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Don't autosave if no real buffers are open.

\(fn ORIG-FN &rest ARGS)" nil nil)

(autoload '+workspaces*switch-project-by-name "~/.emacs.d/modules/feature/workspaces/autoload/workspaces" "\
Switch to a project and prompt for a file to open.

Ensures the scratch (or dashboard) buffers are CDed into the project's root.

\(fn ORIG-FN &rest ARGS)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/feature/workspaces/autoload/evil"
;;;;;;  "modules/feature/workspaces/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/feature/workspaces/autoload/evil.el
 (autoload '+workspace:save "/home/maruku/.emacs.d/modules/feature/workspaces/autoload/evil" nil t)
 (autoload '+workspace:load "~/.emacs.d/modules/feature/workspaces/autoload/evil" nil t)
 (autoload '+workspace:new "~/.emacs.d/modules/feature/workspaces/autoload/evil" nil t)
 (autoload '+workspace:rename "~/.emacs.d/modules/feature/workspaces/autoload/evil" nil t)
 (autoload '+workspace:delete "~/.emacs.d/modules/feature/workspaces/autoload/evil" nil t)
 (autoload '+workspace:switch-next "~/.emacs.d/modules/feature/workspaces/autoload/evil" nil t)
 (autoload '+workspace:switch-previous "~/.emacs.d/modules/feature/workspaces/autoload/evil" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/emacs-lisp/autoload"
;;;;;;  "modules/lang/emacs-lisp/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/emacs-lisp/autoload.el

(autoload '+emacs-lisp-eval "/home/maruku/.emacs.d/modules/lang/emacs-lisp/autoload" "\
Evaluate a region and print it to the echo area (if one line long), otherwise
to a pop up buffer.

\(fn BEG END)" nil nil)

(autoload '+emacs-lisp-highlight-vars-and-faces "~/.emacs.d/modules/lang/emacs-lisp/autoload" "\
Match defined variables and functions.

Functions are differentiated into special forms, built-in functions and
library/userland functions

\(fn END)" nil nil)

(autoload '+emacs-lisp/open-repl "~/.emacs.d/modules/lang/emacs-lisp/autoload" "\
Open the Emacs Lisp REPL (`ielm').

\(fn)" t nil)

(autoload '+emacs-lisp|extend-imenu "~/.emacs.d/modules/lang/emacs-lisp/autoload" "\
Improve imenu support with better expression regexps and Doom-specific forms.

\(fn)" nil nil)

(autoload '+emacs-lisp|disable-flycheck-maybe "~/.emacs.d/modules/lang/emacs-lisp/autoload" "\
Disable flycheck-mode if in emacs.d.

\(fn)" nil nil)

(autoload '+emacs-lisp-lookup-documentation "~/.emacs.d/modules/lang/emacs-lisp/autoload" "\
Lookup THING with `helpful-variable' if it's a variable, `helpful-callable'
if it's callable, `apropos' otherwise.

\(fn THING)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/go/autoload"
;;;;;;  "modules/lang/go/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/go/autoload.el

(autoload '+go/test-rerun "/home/maruku/.emacs.d/modules/lang/go/autoload" "\


\(fn)" t nil)

(autoload '+go/test-all "~/.emacs.d/modules/lang/go/autoload" "\


\(fn)" t nil)

(autoload '+go/test-nested "~/.emacs.d/modules/lang/go/autoload" "\


\(fn)" t nil)

(autoload '+go/test-single "~/.emacs.d/modules/lang/go/autoload" "\


\(fn)" t nil)

(autoload '+go/play-buffer-or-region "~/.emacs.d/modules/lang/go/autoload" "\
TODO

\(fn &optional BEG END)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/javascript/autoload"
;;;;;;  "modules/lang/javascript/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/javascript/autoload.el

(autoload '+javascript-npm-conf "/home/maruku/.emacs.d/modules/lang/javascript/autoload" "\
Retrieves an alist of this project's 'package.json'. If REFRESH-P is non-nil
ignore the cache.

\(fn &optional PROJECT-ROOT REFRESH-P)" nil nil)

(autoload '+javascript-npm-dep-p "~/.emacs.d/modules/lang/javascript/autoload" "\


\(fn PACKAGES &optional PROJECT-ROOT REFRESH-P)" nil nil)

(autoload '+javascript/open-repl "~/.emacs.d/modules/lang/javascript/autoload" "\
Open a Javascript REPL. Meaning either `skewer-repl', if any of the
skewer-*-mode's are enabled, or `nodejs-repl' otherwise.

\(fn)" t nil)

(autoload '+javascript/skewer-this-buffer "~/.emacs.d/modules/lang/javascript/autoload" "\
Toggle a globalized skewer-mode, attaching an external browser (once),
initiating an internal httpd server (once) and enabling the appropriate
skewer-mode for the current buffer.

Run this for any buffer you want to skewer.

\(fn)" t nil)

(autoload '+javascript/skewer-cleanup "~/.emacs.d/modules/lang/javascript/autoload" "\
Disable skewer-mode globally and disable the httpd server.

\(fn)" t nil)

(autoload '+javascript|add-node-modules-path "~/.emacs.d/modules/lang/javascript/autoload" "\
Add current project's `node_modules/.bin` to `exec-path', so js tools
prioritize project-local packages over global ones.

\(fn)" nil nil)

(autoload '+javascript|cleanup-tide-processes "~/.emacs.d/modules/lang/javascript/autoload" "\
Clean up dangling tsserver processes if there are no more buffers with
`tide-mode' active that belong to that server's project.

\(fn)" nil nil)

(autoload '+javascript*tide-project-root "~/.emacs.d/modules/lang/javascript/autoload" "\
Resolve to `doom-project-root' if `tide-project-root' fails.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/markdown/autoload"
;;;;;;  "modules/lang/markdown/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/markdown/autoload.el

(autoload '+markdown/insert-del "/home/maruku/.emacs.d/modules/lang/markdown/autoload" "\
Surround region in github strike-through delimiters.

\(fn)" t nil)

(autoload '+markdown-flyspell-word-p "~/.emacs.d/modules/lang/markdown/autoload" "\
Return t if point is on a word that should be spell checked.

Return nil if on a link url, markup, html, or references.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/org/autoload/tables"
;;;;;;  "modules/lang/org/autoload/tables.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/org/autoload/tables.el

(autoload '+org/table-next-row "/home/maruku/.emacs.d/modules/lang/org/autoload/tables" "\
Go to the next row (same column) in the current table.

\(fn)" t nil)

(autoload '+org/table-previous-row "~/.emacs.d/modules/lang/org/autoload/tables" "\
Go to the previous row (same column) in the current table. Before doing so,
re-align the table if necessary. (Necessary because org-mode has a
`org-table-next-row', but not `org-table-previous-row')

\(fn)" t nil)

(autoload '+org/table-next-field "~/.emacs.d/modules/lang/org/autoload/tables" "\


\(fn)" t nil)

(autoload '+org/table-previous-field "~/.emacs.d/modules/lang/org/autoload/tables" "\


\(fn)" t nil)

(autoload '+org/table-append-field-or-shift-right "~/.emacs.d/modules/lang/org/autoload/tables" "\


\(fn)" t nil)

(autoload '+org/table-prepend-field-or-shift-left "~/.emacs.d/modules/lang/org/autoload/tables" "\


\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/org/autoload/org"
;;;;;;  "modules/lang/org/autoload/org.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/org/autoload/org.el

(autoload '+org-get-property "/home/maruku/.emacs.d/modules/lang/org/autoload/org" "\
Get a document property named NAME (string) from an org FILE (defaults to
current file). Only scans first 2048 bytes of the document.

\(fn NAME &optional FILE BOUND)" nil nil)

(autoload '+org-get-todo-keywords-for "~/.emacs.d/modules/lang/org/autoload/org" "\
TODO

\(fn KEYWORD)" nil nil)

(autoload '+org-pretty-mode "~/.emacs.d/modules/lang/org/autoload/org" "\
Hides emphasis markers and toggles pretty entities.

\(fn &optional ARG)" t nil)

(autoload '+org/dwim-at-point "~/.emacs.d/modules/lang/org/autoload/org" "\
Do-what-I-mean at point.

If on a:
- checkbox list item or todo heading: toggle it.
- clock: update its time.
- headline: toggle latex fragments and inline images underneath.
- footnote reference: jump to the footnote's definition
- footnote definition: jump to the first reference of this footnote
- table-row or a TBLFM: recalculate the table's formulas
- table-cell: clear it and go into insert mode. If this is a formula cell,
  recaluclate it instead.
- babel-call: execute the source block
- statistics-cookie: update it.
- latex fragment: toggle it.
- link: follow it
- otherwise, refresh all inline images in current tree.

\(fn)" t nil)

(autoload '+org/insert-item "~/.emacs.d/modules/lang/org/autoload/org" "\
Inserts a new heading, table cell or item, depending on the context.
DIRECTION can be 'above or 'below.

I use this instead of `org-insert-item' or `org-insert-heading' which are too
opinionated and perform this simple task incorrectly (e.g. whitespace in the
wrong places).

\(fn DIRECTION)" t nil)

(autoload '+org/dedent "~/.emacs.d/modules/lang/org/autoload/org" "\
TODO

\(fn)" t nil)

(autoload '+org/refresh-inline-images "~/.emacs.d/modules/lang/org/autoload/org" "\
Refresh image previews in the current heading/tree.

\(fn)" t nil)

(autoload '+org/remove-link "~/.emacs.d/modules/lang/org/autoload/org" "\
Unlink the text at point.

\(fn)" t nil)

(autoload '+org/toggle-checkbox "~/.emacs.d/modules/lang/org/autoload/org" "\
Toggle the presence of a checkbox in the current item.

\(fn)" t nil)

(defalias #'+org/toggle-fold #'+org|cycle-only-current-subtree)

(autoload '+org/open-fold "~/.emacs.d/modules/lang/org/autoload/org" "\
Open the current fold (not but its children).

\(fn)" t nil)

(defalias #'+org/close-fold #'outline-hide-subtree)

(autoload '+org/show-next-fold-level "~/.emacs.d/modules/lang/org/autoload/org" "\
Decrease the fold-level of the visible area of the buffer. This unfolds
another level of headings on each invocation.

\(fn)" t nil)

(autoload '+org/hide-next-fold-level "~/.emacs.d/modules/lang/org/autoload/org" "\
Increase the global fold-level of the visible area of the buffer. This folds
another level of headings on each invocation.

\(fn)" t nil)

(autoload '+org|delete-backward-char-and-realign-table-maybe "~/.emacs.d/modules/lang/org/autoload/org" "\
TODO

\(fn)" nil nil)

(autoload '+org|indent-maybe "~/.emacs.d/modules/lang/org/autoload/org" "\
Indent the current item (header or item), if possible. Made for
`org-tab-first-hook' in evil-mode.

\(fn)" t nil)

(autoload '+org|realign-table-maybe "~/.emacs.d/modules/lang/org/autoload/org" "\
Auto-align table under cursor and re-calculate formulas.

\(fn)" nil nil)

(autoload '+org|update-cookies "~/.emacs.d/modules/lang/org/autoload/org" "\
Update counts in headlines (aka \"cookies\").

\(fn)" nil nil)

(autoload '+org|yas-expand-maybe "~/.emacs.d/modules/lang/org/autoload/org" "\
Tries to expand a yasnippet snippet, if one is available. Made for
`org-tab-first-hook'.

\(fn)" nil nil)

(autoload '+org|cycle-only-current-subtree "~/.emacs.d/modules/lang/org/autoload/org" "\
Toggle the local fold at the point (as opposed to cycling through all levels
with `org-cycle').

\(fn &optional ARG)" t nil)

(autoload '+org|remove-occur-highlights "~/.emacs.d/modules/lang/org/autoload/org" "\
Remove org occur highlights on ESC in normal mode.

\(fn)" nil nil)

(autoload '+org*fix-newline-and-indent-in-src-blocks "~/.emacs.d/modules/lang/org/autoload/org" "\
Try to mimic `newline-and-indent' with correct indentation in src blocks.

\(fn)" nil nil)

(autoload '+org*realign-table-maybe "~/.emacs.d/modules/lang/org/autoload/org" "\
Auto-align table under cursor and re-calculate formulas.

\(fn &rest _)" nil nil)

(autoload '+org*evil-org-open-below "~/.emacs.d/modules/lang/org/autoload/org" "\
Fix o/O creating new list items in the middle of nested plain lists. Only has
an effect when `evil-org-special-o/O' has `item' in it (not the default).

\(fn ORIG-FN COUNT)" nil nil)

(autoload '+org*display-link-in-eldoc "~/.emacs.d/modules/lang/org/autoload/org" "\
Display the link at point in eldoc.

\(fn ORIG-FN &rest ARGS)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/org/autoload/org-present"
;;;;;;  "modules/lang/org/autoload/org-present.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/org/autoload/org-present.el

(autoload '+org-present/start "/home/maruku/.emacs.d/modules/lang/org/autoload/org-present" "\
TODO

\(fn)" t nil)

(autoload '+org-present|add-overlays "~/.emacs.d/modules/lang/org/autoload/org-present" "\


\(fn)" nil nil)

(autoload '+org-present|remove-overlays "~/.emacs.d/modules/lang/org/autoload/org-present" "\


\(fn)" nil nil)

(autoload '+org-present|detect-slide "~/.emacs.d/modules/lang/org/autoload/org-present" "\


\(fn)" nil nil)

(autoload '+org-present|init-org-tree-window "~/.emacs.d/modules/lang/org/autoload/org-present" "\
Set up the org window for presentation.

\(fn)" nil nil)

(autoload '+org-present*narrow-to-subtree "~/.emacs.d/modules/lang/org/autoload/org-present" "\
Narrow to the target subtree when you start the presentation.

\(fn ORIG-FN &rest ARGS)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/org/autoload/org-link"
;;;;;;  "modules/lang/org/autoload/org-link.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/org/autoload/org-link.el

(autoload '+org-link-read-file "/home/maruku/.emacs.d/modules/lang/org/autoload/org-link" "\


\(fn KEY DIR)" nil nil)

(autoload '+org-link-read-directory "~/.emacs.d/modules/lang/org/autoload/org-link" "\


\(fn KEY DIR)" nil nil)

(autoload '+org-inline-data-image "~/.emacs.d/modules/lang/org/autoload/org-link" "\
Interpret LINK as base64-encoded image data.

\(fn PROTOCOL LINK DESCRIPTION)" nil nil)

(autoload '+org-image-link "~/.emacs.d/modules/lang/org/autoload/org-link" "\
Interpret LINK as base64-encoded image data.

\(fn PROTOCOL LINK DESCRIPTION)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/org/autoload/org-capture"
;;;;;;  "modules/lang/org/autoload/org-capture.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/org/autoload/org-capture.el

(defvar +org-capture-frame-parameters `((name . "org-capture") (width . 70) (height . 25) (transient . t) ,(if IS-LINUX '(display . ":0"))) "\
TODO")

(autoload '+org-capture|cleanup-frame "/home/maruku/.emacs.d/modules/lang/org/autoload/org-capture" "\
Closes the org-capture frame once done adding an entry.

\(fn)" nil nil)

(autoload '+org-capture-frame-p "~/.emacs.d/modules/lang/org/autoload/org-capture" "\
Return t if the current frame is an org-capture frame opened by
`+org-capture/open-frame'.

\(fn &rest _)" nil nil)

(autoload '+org-capture/open-frame "~/.emacs.d/modules/lang/org/autoload/org-capture" "\
Opens the org-capture window in a floating frame that cleans itself up once
you're done. This can be called from an external shell script.

\(fn &optional STRING KEY)" t nil)

(autoload '+org-capture-available-keys "~/.emacs.d/modules/lang/org/autoload/org-capture" "\
TODO

\(fn)" nil nil)

(autoload '+org-capture-todo-file "~/.emacs.d/modules/lang/org/autoload/org-capture" "\
Expand `+org-capture-todo-file' from `org-directory'.
If it is an absolute path return `+org-capture-todo-file' verbatim.

\(fn)" nil nil)

(autoload '+org-capture-notes-file "~/.emacs.d/modules/lang/org/autoload/org-capture" "\
Expand `+org-capture-notes-file' from `org-directory'.
If it is an absolute path return `+org-capture-todo-file' verbatim.

\(fn)" nil nil)

(autoload '+org-capture-project-todo-file "~/.emacs.d/modules/lang/org/autoload/org-capture" "\
Find the nearest `+org-capture-todo-file' in a parent directory, otherwise,
opens a blank one at the project root. Throws an error if not in a project.

\(fn)" nil nil)

(autoload '+org-capture-project-notes-file "~/.emacs.d/modules/lang/org/autoload/org-capture" "\
Find the nearest `+org-capture-notes-file' in a parent directory, otherwise,
opens a blank one at the project root. Throws an error if not in a project.

\(fn)" nil nil)

(autoload '+org-capture-project-changelog-file "~/.emacs.d/modules/lang/org/autoload/org-capture" "\
Find the nearest `+org-capture-changelog-file' in a parent directory,
otherwise, opens a blank one at the project root. Throws an error if not in a
project.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/org/autoload/org-attach"
;;;;;;  "modules/lang/org/autoload/org-attach.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/org/autoload/org-attach.el

(autoload '+org-attach/sync "/home/maruku/.emacs.d/modules/lang/org/autoload/org-attach" "\
Reindex all attachments in `org-directory' and delete orphaned attachments in
`org-attach-directory'. If ARG (universal arg), conduct a dry run.

\(fn ARG)" t nil)

(function-put '+org-attach/sync 'interactive-only 't)

(autoload '+org-attach/find-file "~/.emacs.d/modules/lang/org/autoload/org-attach" "\
Open a file from `org-attach-directory'.

\(fn)" t nil)

(autoload '+org-attach/file "~/.emacs.d/modules/lang/org/autoload/org-attach" "\
Copies the file at PATH to `+org-attach-dir' and places an org link to it at
the cursor.

\(fn PATH)" t nil)

(autoload '+org-attach/uri "~/.emacs.d/modules/lang/org/autoload/org-attach" "\
Downloads the file at URL and place an org link to it at the cursor.

\(fn URI)" t nil)

(autoload '+org-attach-download-dnd "~/.emacs.d/modules/lang/org/autoload/org-attach" "\
TODO

\(fn URI ACTION)" nil nil)

(autoload '+org-attach*insert-link "~/.emacs.d/modules/lang/org/autoload/org-attach" "\
Produces and inserts a link to FILENAME into the document.

If FILENAME is an image, produce an attach:%s path, otherwise use file:%s (with
an file icon produced by `+org-attach--icon').

\(fn LINK FILENAME)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/python/autoload/python"
;;;;;;  "modules/lang/python/autoload/python.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/python/autoload/python.el

(autoload '+python/open-repl "/home/maruku/.emacs.d/modules/lang/python/autoload/python" "\
Open the Python REPL.

\(fn)" t nil)

(autoload '+python/open-ipython-repl "~/.emacs.d/modules/lang/python/autoload/python" "\
Open an IPython REPL.

\(fn)" t nil)

(autoload '+python/open-jupyter-repl "~/.emacs.d/modules/lang/python/autoload/python" "\
Open a Jupyter console.

\(fn)" t nil)

(autoload '+python-executable-find "~/.emacs.d/modules/lang/python/autoload/python" "\
TODO

\(fn EXE)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/sh/autoload"
;;;;;;  "modules/lang/sh/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/sh/autoload.el

(autoload '+sh--match-variables-in-quotes "/home/maruku/.emacs.d/modules/lang/sh/autoload" "\
Search for variables in double-quoted strings bounded by LIMIT.

\(fn LIMIT)" nil nil)

(autoload '+sh--match-command-subst-in-quotes "~/.emacs.d/modules/lang/sh/autoload" "\
Search for variables in double-quoted strings bounded by LIMIT.

\(fn LIMIT)" nil nil)

(autoload '+sh/open-repl "~/.emacs.d/modules/lang/sh/autoload" "\
Open a shell REPL.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/web/autoload/html"
;;;;;;  "modules/lang/web/autoload/html.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/web/autoload/html.el

(autoload '+web-encode-entities "/home/maruku/.emacs.d/modules/lang/web/autoload/html" "\
TODO

\(fn TEXT)" nil nil)

(autoload '+web-decode-entities "~/.emacs.d/modules/lang/web/autoload/html" "\
TODO

\(fn TEXT)" nil nil)

(autoload '+web/encode-entities-region "~/.emacs.d/modules/lang/web/autoload/html" "\
Encode HTML entities in region.

\(fn BEG END)" t nil)

(autoload '+web/decode-entities-region "~/.emacs.d/modules/lang/web/autoload/html" "\
Decode HTML entities in region.

\(fn BEG END)" t nil)

(autoload '+web/indent-or-yas-or-emmet-expand "~/.emacs.d/modules/lang/web/autoload/html" "\
Invoke `indent-for-tab-command' if at or before text bol, `yas-expand' if on
a snippet, or `emmet-expand-yas'/`emmet-expand-line', depending on whether
`yas-minor-mode' is enabled or not.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/web/autoload/evil"
;;;;;;  "modules/lang/web/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/web/autoload/evil.el
 (autoload '+web:encode-html-entities "/home/maruku/.emacs.d/modules/lang/web/autoload/evil" nil t)
 (autoload '+web:decode-html-entities "~/.emacs.d/modules/lang/web/autoload/evil" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/lang/web/autoload/css"
;;;;;;  "modules/lang/web/autoload/css.el" (0 0 0 0))
;;; Generated autoloads from modules/lang/web/autoload/css.el

(autoload '+css/toggle-inline-or-block "/home/maruku/.emacs.d/modules/lang/web/autoload/css" "\
Toggles between a bracketed block and inline block.

\(fn)" t nil)

(autoload '+css/comment-indent-new-line "~/.emacs.d/modules/lang/web/autoload/css" "\
Continues the comment in an indented new line in css-mode and scss-mode.
Meant for `comment-line-break-function'.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/tools/flycheck/autoload"
;;;;;;  "modules/tools/flycheck/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/tools/flycheck/autoload.el

(autoload '+flycheck|init-popups "/home/maruku/.emacs.d/modules/tools/flycheck/autoload" "\
Activate `flycheck-posframe-mode' if available and in GUI Emacs.
Activate `flycheck-popup-tip-mode' otherwise.
Do nothing if `lsp-ui-mode' is active and `lsp-ui-sideline-enable' is non-nil.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/tools/gist/autoload/gist"
;;;;;;  "modules/tools/gist/autoload/gist.el" (0 0 0 0))
;;; Generated autoloads from modules/tools/gist/autoload/gist.el

(autoload '+gist/open-current "/home/maruku/.emacs.d/modules/tools/gist/autoload/gist" "\


\(fn)" t nil)

(autoload '+gist/kill-cache "~/.emacs.d/modules/tools/gist/autoload/gist" "\
Clears the gist cache. Necessary when a faulty cache causes gist.el to be
entirely unuseable.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/tools/gist/autoload/evil"
;;;;;;  "modules/tools/gist/autoload/evil.el" (0 0 0 0))
;;; Generated autoloads from modules/tools/gist/autoload/evil.el
 (autoload '+gist:send "/home/maruku/.emacs.d/modules/tools/gist/autoload/evil" nil t)
 (autoload '+gist:list "~/.emacs.d/modules/tools/gist/autoload/evil" nil t)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/tools/magit/autoload"
;;;;;;  "modules/tools/magit/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/tools/magit/autoload.el

(autoload '+magit-display-buffer "/home/maruku/.emacs.d/modules/tools/magit/autoload" "\
Like `magit-display-buffer-fullframe-status-v1' with two differences:

1. Magit sub-buffers that aren't spawned from a status screen are opened as
   popups.
2. The status screen isn't buried when viewing diffs or logs from the status
   screen.

\(fn BUFFER)" nil nil)

(autoload '+magit-display-popup-buffer "~/.emacs.d/modules/tools/magit/autoload" "\
TODO

\(fn BUFFER &optional ALIST)" nil nil)

(autoload '+magit/quit "~/.emacs.d/modules/tools/magit/autoload" "\
Clean up magit buffers after quitting `magit-status' and refresh version
control in buffers.

\(fn &optional KILL-BUFFER)" t nil)

(autoload '+magit/clone "~/.emacs.d/modules/tools/magit/autoload" "\
Like `magit-clone', but supports additional formats on top of absolute URLs:

+ USER/REPO: assumes {`+magit-default-clone-url'}/USER/REPO
+ REPO: assumes {`+magit-default-clone-url'}/{USER}/REPO, where {USER} is
  ascertained from your global gitconfig.

\(fn URL-OR-REPO DIR)" t nil)

(autoload '+magit*hub-settings--format-magithub\.enabled "~/.emacs.d/modules/tools/magit/autoload" "\
Change the setting to display 'false' as its default.

\(fn)" nil nil)

(autoload '+magit*hub-enabled-p "~/.emacs.d/modules/tools/magit/autoload" "\
Disables magithub by default.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/tools/password-store/autoload"
;;;;;;  "modules/tools/password-store/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/tools/password-store/autoload.el
 (autoload 'auth-source-pass-parse-entry "/usr/share/emacs/26.1/lisp/auth-source-pass")

(defalias '+pass-get-entry #'auth-source-pass-parse-entry)

(autoload '+pass-get-field "/home/maruku/.emacs.d/modules/tools/password-store/autoload" "\
Fetches the value of a field. FIELDS can be a list of string field names or a
single one. If a list, the first field found will be returned. Will error out
otherwise, unless NOERROR is non-nill.

\(fn ENTRY FIELDS &optional NOERROR)" nil nil)

(autoload '+pass-get-user "~/.emacs.d/modules/tools/password-store/autoload" "\
Fetches the user field from ENTRY. Each of `+pass-user-fields' are tried in
search of your username. May prompt for your gpg passphrase.

\(fn ENTRY)" nil nil)

(autoload '+pass-get-secret "~/.emacs.d/modules/tools/password-store/autoload" "\
Fetches your secret from ENTRY. May prompt for your gpg passphrase.

\(fn ENTRY)" nil nil)
 (autoload 'password-store-dir "password-store")
 (autoload 'password-store-list "password-store")
 (autoload 'password-store--completing-read "password-store")

(autoload '+pass/edit-entry "~/.emacs.d/modules/tools/password-store/autoload" "\
Interactively search for and open a pass entry for editing.

\(fn ENTRY)" t nil)

(autoload '+pass/copy-field "~/.emacs.d/modules/tools/password-store/autoload" "\
Interactively search for an entry and copy a particular field to your
clipboard.

\(fn ENTRY)" t nil)

(autoload '+pass/copy-secret "~/.emacs.d/modules/tools/password-store/autoload" "\
Interactively search for an entry and copy its secret/password to your
clipboard.

\(fn ENTRY)" t nil)

(autoload '+pass/copy-user "~/.emacs.d/modules/tools/password-store/autoload" "\
Interactively search for an entry and copy the login to your clipboard. The
fields in `+pass-user-fields' is used to find the login field.

\(fn ENTRY)" t nil)

(autoload '+pass/browse-url "~/.emacs.d/modules/tools/password-store/autoload" "\
Interactively search for an entry and open its url in your browser. The
fields in `+pass-url-fields' is used to find the url field.

\(fn ENTRY)" t nil)

(autoload '+pass/ivy "~/.emacs.d/modules/tools/password-store/autoload" "\
TODO

\(fn ARG)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/doom-dashboard/autoload"
;;;;;;  "modules/ui/doom-dashboard/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/doom-dashboard/autoload.el

(autoload '+doom-dashboard/open "/home/maruku/.emacs.d/modules/ui/doom-dashboard/autoload" "\
Switch to the dashboard in the current window, of the current FRAME.

\(fn FRAME)" t nil)

(autoload '+doom-dashboard/forward-button "~/.emacs.d/modules/ui/doom-dashboard/autoload" "\
Like `forward-button', but don't wrap.

\(fn N)" t nil)

(autoload '+doom-dashboard/backward-button "~/.emacs.d/modules/ui/doom-dashboard/autoload" "\
Like `backward-button', but don't wrap.

\(fn N)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/hl-todo/autoload"
;;;;;;  "modules/ui/hl-todo/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/hl-todo/autoload.el

(autoload '+hl-todo|use-face-detection "/home/maruku/.emacs.d/modules/ui/hl-todo/autoload" "\
Use a different, more primitive method of locating todo keywords.

This is useful for major modes that don't use or have a valid syntax-table entry
for comment start/end characters.

\(fn)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/modeline/autoload"
;;;;;;  "modules/ui/modeline/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/modeline/autoload.el

(autoload '+modeline|resize-for-big-font "/home/maruku/.emacs.d/modules/ui/modeline/autoload" "\
Adjust the modeline's height when `doom-big-font-mode' is enabled. This was
made to be added to `doom-big-font-mode-hook'.

\(fn)" nil nil)

(autoload '+modeline|update-env-in-all-windows "~/.emacs.d/modules/ui/modeline/autoload" "\
Update version strings in all buffers.

\(fn &rest _)" nil nil)

(autoload '+modeline|clear-env-in-all-windows "~/.emacs.d/modules/ui/modeline/autoload" "\
Blank out version strings in all buffers.

\(fn &rest _)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/nav-flash/autoload"
;;;;;;  "modules/ui/nav-flash/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/nav-flash/autoload.el

(autoload '+nav-flash-blink-cursor "/home/maruku/.emacs.d/modules/ui/nav-flash/autoload" "\
Blinks the current line in the current window, to make it clear where the
cursor has landed (typically after a large motion, like switching windows or
jumping to another part of the file).

\(fn &rest _)" nil nil)

(autoload '+nav-flash-blink-cursor-maybe "~/.emacs.d/modules/ui/nav-flash/autoload" "\
Like `+nav-flash-blink-cursor', but no-ops if in special-mode or term-mode,
or triggered from one of `+nav-flash-exclude-commands'.

\(fn &rest _)" nil nil)

(autoload '+nav-flash|delayed-blink-cursor "~/.emacs.d/modules/ui/nav-flash/autoload" "\
Like `+nav-flash-blink-cursor', but links after a tiny pause, in case it
isn't clear at run-time if the point will be in the correct window/buffer (like
for `org-follow-link-hook').

\(fn &rest _)" nil nil)

(defalias '+nav-flash|blink-cursor #'+nav-flash-blink-cursor)

(defalias '+nav-flash|blink-cursor-maybe #'+nav-flash-blink-cursor-maybe)

(defalias '+nav-flash*blink-cursor #'+nav-flash-blink-cursor-maybe)

(autoload '+nav-flash/blink-cursor "~/.emacs.d/modules/ui/nav-flash/autoload" "\
Blink current line using `nav-flash'.

\(fn &rest _)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/neotree/autoload"
;;;;;;  "modules/ui/neotree/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/neotree/autoload.el

(autoload '+neotree/open "/home/maruku/.emacs.d/modules/ui/neotree/autoload" "\
Open the neotree window in the current project.

\(fn)" t nil)

(autoload '+neotree/find-this-file "~/.emacs.d/modules/ui/neotree/autoload" "\
Open the neotree window in the current project, and find the current file.

\(fn)" t nil)

(autoload '+neotree/collapse-or-up "~/.emacs.d/modules/ui/neotree/autoload" "\
Collapse an expanded directory node or go to the parent node.

\(fn)" t nil)

(autoload '+neotree/collapse "~/.emacs.d/modules/ui/neotree/autoload" "\
Collapse a neotree node.

\(fn)" t nil)

(autoload '+neotree/expand-or-open "~/.emacs.d/modules/ui/neotree/autoload" "\
Expand or open a neotree node.

\(fn)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/popup/autoload/settings"
;;;;;;  "modules/ui/popup/autoload/settings.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/popup/autoload/settings.el

(defvar +popup--display-buffer-alist nil)

(defvar +popup-defaults (list :side 'bottom :height 0.16 :width 40 :quit t :select #'ignore :ttl 5) "\
Default properties for popup rules defined with `set-popup-rule!'.")

(autoload '+popup--make "/home/maruku/.emacs.d/modules/ui/popup/autoload/settings" "\


\(fn PREDICATE PLIST)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/popup/autoload/popup"
;;;;;;  "modules/ui/popup/autoload/popup.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/popup/autoload/popup.el

(autoload '+popup--init "/home/maruku/.emacs.d/modules/ui/popup/autoload/popup" "\
Initializes a popup window. Run any time a popup is opened. It sets the
default window parameters for popup windows, clears leftover transient timers
and enables `+popup-buffer-mode'.

\(fn WINDOW &optional ALIST)" nil nil)

(autoload '+popup-buffer-p "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Return non-nil if BUFFER is a popup buffer. Defaults to the current buffer.

\(fn &optional BUFFER)" nil nil)

(autoload '+popup-window-p "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Return non-nil if WINDOW is a popup window. Defaults to the current window.

\(fn &optional WINDOW)" nil nil)

(autoload '+popup-buffer "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Open BUFFER in a popup window. ALIST describes its features.

\(fn BUFFER &optional ALIST)" nil nil)

(autoload '+popup-parameter "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Fetch the window PARAMETER (symbol) of WINDOW

\(fn PARAMETER &optional WINDOW)" nil nil)

(autoload '+popup-parameter-fn "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Fetch the window PARAMETER (symbol) of WINDOW. If it is a function, run it
with ARGS to get its return value.

\(fn PARAMETER &optional WINDOW &rest ARGS)" nil nil)

(autoload '+popup-windows "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Returns a list of all popup windows.

\(fn)" nil nil)

(autoload '+popup-shrink-to-fit "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Shrinks WINDOW to fit the buffer contents, if the buffer isn't empty.

Uses `shrink-window-if-larger-than-buffer'.

\(fn &optional WINDOW)" nil nil)

(autoload '+popup-alist-from-window-state "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Convert window STATE (from `window-state-get') to a `display-buffer' alist.

\(fn STATE)" nil nil)

(autoload '+popup|adjust-fringes "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Hides the fringe in popup windows, restoring them if `+popup-buffer-mode' is
disabled.

\(fn)" nil nil)

(autoload '+popup|adjust-margins "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Creates padding for the popup window determined by `+popup-margin-width',
restoring it if `+popup-buffer-mode' is disabled.

\(fn)" nil nil)

(autoload '+popup|set-modeline-on-enable "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Don't show modeline in popup windows without a `modeline' window-parameter.
Possible values for this parameter are:

  t            show the mode-line as normal
  nil          hide the modeline entirely (the default)
  a function   `mode-line-format' is set to its return value

Any non-nil value besides the above will be used as the raw value for
`mode-line-format'.

\(fn)" nil nil)

(autoload '+popup|unset-modeline-on-disable "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Restore the modeline when `+popup-buffer-mode' is deactivated.

\(fn)" nil nil)

(autoload '+popup|close-on-escape "~/.emacs.d/modules/ui/popup/autoload/popup" "\
If called inside a popup, try to close that popup window (see
`+popup/close'). If called outside, try to close all popup windows (see
`+popup/close-all').

\(fn)" nil nil)

(autoload '+popup|cleanup-rules "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Cleans up any duplicate popup rules.

\(fn)" t nil)

(autoload '+popup|kill-buffer-hook "~/.emacs.d/modules/ui/popup/autoload/popup" "\
TODO

\(fn)" nil nil)

(defalias 'other-popup #'+popup/other)

(autoload '+popup/buffer "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Open this buffer in a popup window.

\(fn)" t nil)

(autoload '+popup/other "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Cycle through popup windows, like `other-window'. Ignores regular windows.

\(fn)" t nil)

(autoload '+popup/close "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Close WINDOW, if it's a popup window.

This will do nothing if the popup's `quit' window parameter is either nil or
'other. This window parameter is ignored if FORCE-P is non-nil.

\(fn &optional WINDOW FORCE-P)" t nil)

(autoload '+popup/close-all "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Close all open popup windows.

This will ignore popups with an `quit' parameter that is either nil or 'current.
This window parameter is ignored if FORCE-P is non-nil.

\(fn &optional FORCE-P)" t nil)

(autoload '+popup/toggle "~/.emacs.d/modules/ui/popup/autoload/popup" "\
If popups are open, close them. If they aren't, restore the last one or open
the message buffer in a popup window.

\(fn)" t nil)

(autoload '+popup/restore "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Restore the last popups that were closed, if any.

\(fn)" t nil)

(autoload '+popup/raise "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Raise the current popup window into a regular window.

\(fn WINDOW)" t nil)

(autoload '+popup/diagnose "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Reveal what popup rule will be used for the current buffer.

\(fn)" t nil)

(autoload '+popup*close "~/.emacs.d/modules/ui/popup/autoload/popup" "\
TODO

\(fn &rest _)" nil nil)

(autoload '+popup*save "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Sets aside all popups before executing the original function, usually to
prevent the popup(s) from messing up the UI (or vice versa).

\(fn ORIG-FN &rest ARGS)" nil nil)

(autoload '+popup-display-buffer-fullframe "~/.emacs.d/modules/ui/popup/autoload/popup" "\
Displays the buffer fullscreen.

\(fn BUFFER ALIST)" nil nil)

(autoload '+popup-display-buffer-stacked-side-window "~/.emacs.d/modules/ui/popup/autoload/popup" "\
A `display-buffer' action that serves as an alternative to
`display-buffer-in-side-window', but allows for stacking popups with the `vslot'
alist entry.

Accepts the same arguments as `display-buffer-in-side-window'. You must set
`window--sides-inhibit-check' to non-nil for this work properly.

\(fn BUFFER ALIST)" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/treemacs/autoload"
;;;;;;  "modules/ui/treemacs/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/treemacs/autoload.el

(autoload '+treemacs/toggle "/home/maruku/.emacs.d/modules/ui/treemacs/autoload" "\
Initialize or toggle treemacs.

Ensures that only the current project is present and all other projects have
been removed.

Use `treemacs' command for old functionality.

\(fn)" t nil)

(autoload '+treemacs/find-file "~/.emacs.d/modules/ui/treemacs/autoload" "\
Open treemacs (if necessary) and find current file.

\(fn ARG)" t nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/vc-gutter/autoload"
;;;;;;  "modules/ui/vc-gutter/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/vc-gutter/autoload.el
 (autoload '+vc-gutter-hydra/body "/home/maruku/.emacs.d/modules/ui/vc-gutter/autoload" nil nil)

;;;***

;;;### (autoloads nil "/home/maruku/.emacs.d/modules/ui/vi-tilde-fringe/autoload"
;;;;;;  "modules/ui/vi-tilde-fringe/autoload.el" (0 0 0 0))
;;; Generated autoloads from modules/ui/vi-tilde-fringe/autoload.el

(add-hook! (prog-mode text-mode conf-mode) #'vi-tilde-fringe-mode)

(put (quote set-email-account!) (quote doom-file) "~/.emacs.d/modules/app/email/autoload/email.el")
(defmacro set-email-account! (label letvars &optional default-p) "THIS FUNCTION DOES NOTHING BECAUSE (:app . email) IS DISABLED

Registers an email address for mu4e. The LABEL is a string. LETVARS are a
list of cons cells (VARIABLE . VALUE) -- you may want to modify:

 + `user-full-name' (this or the global `user-full-name' is required)
 + `user-mail-address' (required)
 + `smtpmail-smtp-user' (required for sending mail from Emacs)

OPTIONAL:
 + `mu4e-sent-folder'
 + `mu4e-drafts-folder'
 + `mu4e-trash-folder'
 + `mu4e-refile-folder'
 + `mu4e-compose-signature'

DEFAULT-P is a boolean. If non-nil, it marks that email account as the
default/fallback account." (ignore label letvars default-p))
(put (quote set-email-account!) (quote doom-module) (quote (:app . email)))
(put (quote set-irc-server!) (quote doom-file) "~/.emacs.d/modules/app/irc/autoload/settings.el")
(defmacro set-irc-server! (server letvars) "THIS FUNCTION DOES NOTHING BECAUSE (:app . irc) IS DISABLED

Registers an irc SERVER for circe.

See `circe-network-options' for details." (ignore server letvars))
(put (quote set-irc-server!) (quote doom-module) (quote (:app . irc)))
(progn (autoload (quote set-company-backend!) "~/.emacs.d/modules/completion/company/autoload" "Prepends BACKENDS (in order) to `company-backends' in MODES.

MODES should be one symbol or a list of them, representing major or minor modes.
This will overwrite backends for MODES on consecutive uses.

If the car of BACKENDS is nil, unset the backends for MODES.

Examples:

  (set-company-backend! 'js2-mode
    'company-tide 'company-yasnippet)

  (set-company-backend! 'sh-mode
    '(company-shell :with company-yasnippet))

  (set-company-backend! '(c-mode c++-mode)
    '(:separate company-irony-c-headers company-irony))

  (set-company-backend! 'sh-mode nil)  ; unsets backends for sh-mode

To have BACKENDS apply to any mode that is a parent of MODES, set MODES to
:derived, e.g.

  (set-company-backend! :derived 'text-mode 'company-dabbrev 'company-yasnippet)

(fn MODES &rest BACKENDS)" nil nil) (function-put (quote set-company-backend!) (quote lisp-indent-function) (quote defun)))
(put (quote set-company-backend!) (quote doom-module) (quote (:completion . company)))
(put (quote set-formatter!) (quote doom-file) "~/.emacs.d/modules/editor/format/autoload/settings.el")
(cl-defmacro set-formatter! (name formatter &key modes filter ok-statuses error-regexp) "THIS FUNCTION DOES NOTHING BECAUSE (:editor . format) IS DISABLED

Define (or modify) a formatter named NAME.

Supported keywords: :modes :install :filter :ok-statuses :error-regexp

NAME is a symbol that identifies this formatter.

FORMATTER can be a symbol referring to another formatter, a function, string or
nested list.

  If a function, it should be a formatter function that
    `format-all-buffer-thunk' will accept.
  If a string, it is assumed to be a shell command that the buffer's text will
    be piped to (through stdin).
  If a list, it should represent a shell command as a list of arguments. Each
    element is either a string or list (STRING ARG) where STRING is a format
    string and ARG is both a predicate and argument for STRING. If ARG is nil,
    STRING will be omitted from the vector.

MODES is a major mode, a list thereof, or a list of two-element sublists with
the structure: (MAJOR-MODE FORM). FORM is evaluated when the buffer is formatted
and its return value serves two purposes:

  1. It is a predicate for this formatter. Assuming the MAJOR-MODE matches the
     current mode, if FORM evaluates to nil, the formatter is skipped.
  2. It's return value is made available to FORMATTER if it is a function or
     list of shell arguments via the `mode-result' variable.

FILTER is a function that takes three arguments: the formatted output, any error
output and the position of the first change. This function must return these
three after making whatever changes you like to them. This might be useful if
the output contains ANSI color codes that need to be stripped out (as is the
case with elm-format).

OK-STATUSES and ERROR-REGEXP are ignored if FORMATTER is not a shell command.

OK-STATUSES is a list of integer exit codes that should be treated as success
codes. However, if ERROR-REGEXP is given, and the program's stderr contains that
regexp, then the formatting is considered failed even if the exit status is in
OK-STATUSES.

Basic examples:

  (set-formatter! 'asmfmt \"asmfmt\" :modes '(asm-mode nasm-mode))
  (set-formatter! 'black \"black -q -\")
  (set-formatter! 'html-tidy \"tidy -q -indent\" :modes '(html-mode web-mode))

Advanced examples:

  (set-formatter!
    'clang-format
    '(\"clang-format\"
      (\"-assume-filename=%S\" (or buffer-file-name mode-result \"\")))
    :modes
    '((c-mode \".c\")
      (c++-mode \".cpp\")
      (java-mode \".java\")
      (objc-mode \".m\")
      (protobuf-mode \".proto\")))

  (set-formatter! 'html-tidy
    '(\"tidy\" \"-q\" \"-indent\"
      (\"-xml\" (memq major-mode '(nxml-mode xml-mode))))
    :modes
    '(html-mode
      (web-mode (and (equal \"none\" web-mode-engine)
                     (car (member web-mode-content-type '(\"xml\" \"html\"))))))
    :ok-statuses '(0 1)
    :executable \"tidy\")

  (set-formatter! 'html-tidy  ; overwrite predefined html-tidy formatter
    '(\"tidy\" \"-q\" \"-indent\"
      \"--tidy-mark\" \"no\"
      \"--drop-empty-elements\" \"no\"
      \"--show-body-only\" \"auto\"
      (\"--indent-spaces\" \"%d\" tab-width)
      (\"--indent-with-tabs\" \"%s\" (if indent-tabs-mode \"yes\" \"no\"))
      (\"-xml\" (memq major-mode '(nxml-mode xml-mode))))
    :ok-statuses '(0 1)))

  (set-formatter! 'elm-format
    \"elm-format --yes --stdin\"
    :filter
    (lambda (output errput first-diff)
      (list output
            (format-all-remove-ansi-color errput)
            first-diff)))" (ignore name formatter modes filter ok-statuses error-regexp))
(put (quote set-formatter!) (quote doom-module) (quote (:editor . format)))
(progn (autoload (quote set-rotate-patterns!) "~/.emacs.d/modules/editor/rotate-text/autoload" "Declare :symbols, :words or :patterns (all lists of strings) that
`rotate-text' will cycle through.

(fn MODES &key SYMBOLS WORDS PATTERNS)" nil nil) (function-put (quote set-rotate-patterns!) (quote lisp-indent-function) (quote defun)))
(put (quote set-rotate-patterns!) (quote doom-module) (quote (:editor . rotate-text)))
(progn (autoload (quote set-electric!) "~/.emacs.d/modules/emacs/electric/autoload" "Declare that WORDS (list of strings) or CHARS (lists of chars) should trigger
electric indentation.

Enables `electric-indent-local-mode' in MODES.

(fn MODES &key WORDS CHARS)" nil nil) (function-put (quote set-electric!) (quote lisp-indent-function) (quote defun)))
(put (quote set-electric!) (quote doom-module) (quote (:emacs . electric)))
(put (quote set-eshell-alias!) (quote doom-file) "~/.emacs.d/modules/emacs/eshell/autoload/settings.el")
(defmacro set-eshell-alias! (&rest aliases) "THIS FUNCTION DOES NOTHING BECAUSE (:emacs . eshell) IS DISABLED

Define aliases for eshell." (ignore aliases))
(put (quote set-eshell-alias!) (quote doom-module) (quote (:emacs . eshell)))
(autoload (quote set-repl-handler!) "~/.emacs.d/modules/feature/eval/autoload/settings" "Defines a REPL for MODES.

MODES is either a single major mode symbol or a list of them. COMMAND is a
function that creates and returns the REPL buffer.

COMMAND can either be a function that takes no arguments, or an interactive
command that will be called interactively.

(fn MODES COMMAND)" nil nil)
(put (quote set-repl-handler!) (quote doom-module) (quote (:feature . eval)))
(progn (autoload (quote set-eval-handler!) "~/.emacs.d/modules/feature/eval/autoload/settings" "Define a code evaluator for major mode MODE with `quickrun'.

1. If MODE is a string and COMMAND is the string, MODE is a file regexp and
   COMMAND is a string key for an entry in `quickrun-file-alist'.
2. If MODE is not a string and COMMAND is a string, MODE is a major-mode symbol
   and COMMAND is a key (for `quickrun--language-alist'), and will be registered
   in `quickrun--major-mode-alist'.
3. If MODE is not a string and COMMAND is an alist, see `quickrun-add-command':
   (quickrun-add-command MODE COMMAND :mode MODE).
4. If MODE is not a string and COMMANd is a symbol, add it to
   `+eval-runners', which is used by `+eval/region'.

(fn MODE COMMAND)" nil nil) (function-put (quote set-eval-handler!) (quote lisp-indent-function) (quote defun)))
(put (quote set-eval-handler!) (quote doom-module) (quote (:feature . eval)))
(progn (autoload (quote set-evil-initial-state!) "~/.emacs.d/modules/feature/evil/autoload/evil" "Set the initialize STATE of MODES using `evil-set-initial-state'.

(fn MODES STATE)" nil nil) (function-put (quote set-evil-initial-state!) (quote lisp-indent-function) (quote defun)))
(put (quote set-evil-initial-state!) (quote doom-module) (quote (:feature . evil)))
(progn (autoload (quote set-file-template!) "~/.emacs.d/modules/feature/file-templates/autoload" "Register a file template.

PRED can either be a regexp string or a major mode symbol. PLIST may contain
these properties:

  :when FUNCTION
    Provides a secondary predicate. This function takes no arguments and is
    executed from within the target buffer. If it returns nil, this rule will be
    skipped over.
  :trigger STRING|FUNCTION
    If a string, this is the yasnippet trigger keyword used to trigger the
      target snippet.
    If a function, this function will be run in the context of the buffer to
      insert a file template into. It is given no arguments and must insert text
      into the current buffer manually.
    If omitted, `+file-templates-default-trigger' is used.
  :mode SYMBOL
    What mode to get the yasnippet snippet from. If omitted, either PRED (if
    it's a major-mode symbol) or the mode of the buffer is used.
  :project BOOL
    If non-nil, ignore this template if this buffer isn't in a project.
  :ignore BOOL
    If non-nil, don't expand any template for this file and don't test any other
    file template rule against this buffer.

(fn PRED &key WHEN TRIGGER MODE PROJECT IGNORE)" nil nil) (function-put (quote set-file-template!) (quote lisp-indent-function) (quote defun)))
(put (quote set-file-template!) (quote doom-module) (quote (:feature . file-templates)))
(autoload (quote set-file-templates!) "~/.emacs.d/modules/feature/file-templates/autoload" "Like `set-file-templates!', but can register multiple file templates at once.

(fn &rest (PRED &key WHEN TRIGGER MODE PROJECT IGNORE))" nil nil)
(put (quote set-file-templates!) (quote doom-module) (quote (:feature . file-templates)))
(progn (autoload (quote set-lookup-handlers!) "~/.emacs.d/modules/feature/lookup/autoload/lookup" "Define a jump target for major MODES.

This overwrites previously defined handlers for MODES. If used on minor modes,
they are combined with handlers defined for other minor modes or the major mode
it's activated in.

This can be passed nil as its second argument to unset handlers for MODES. e.g.

  (set-lookup-handlers! 'python-mode nil)

Otherwise, these properties are available to be set:

:definition FN
  Run when jumping to a symbol's definition.
  Used by `+lookup/definition'.
:references FN
  Run when looking for usage references of a symbol in the current project.
  Used by `+lookup/references'.
:documentation FN
  Run when looking up documentation for a symbol.
  Used by `+lookup/documentation'.
:file FN
  Run when looking up the file for a symbol/string. Typically a file path.
  Used by `+lookup/file'.
:xref-backend FN
  Defines an xref backend for a major-mode. If you define :definition and
  :references along with :xref-backend, those will have higher precedence.
:async BOOL
  Indicates that the supplied handlers *after* this property are asynchronous.
  Note: async handlers do not fall back to the default handlers, due to their
  nature. To get around this, you must write specialized wrappers to wait for
  the async response and return 'fallback.

(fn MODE-OR-MODES &key ASYNC DEFINITION REFERENCES DOCUMENTATION FILE XREF-BACKEND)" nil nil) (function-put (quote set-lookup-handlers!) (quote lisp-indent-function) (quote defun)))
(put (quote set-lookup-handlers!) (quote doom-module) (quote (:feature . lookup)))
(progn (autoload (quote set-docsets!) "~/.emacs.d/modules/feature/lookup/autoload/docsets" "Registers a list of DOCSETS for MODES.

MODES can be one major mode, or a list thereof.

DOCSETS can be strings, each representing a dash docset, or a vector with the
structure [DOCSET FORM]. If FORM evaluates to nil, the DOCSET is omitted. If it
is non-nil, (format DOCSET FORM) is used as the docset.

The first element in DOCSETS can be :add or :remove, making it easy for users to
add to or remove default docsets from modes.

DOCSETS can also contain sublists, which will be flattened.

Example:

  (set-docsets! '(js2-mode rjsx-mode) \"JavaScript\"
    [\"React\" (eq major-mode 'rjsx-mode)]
    [\"TypeScript\" (bound-and-true-p tide-mode)])

Used by `+lookup/in-docsets' and `+lookup/documentation'.

(fn MODES &rest DOCSETS)" nil nil) (function-put (quote set-docsets!) (quote lisp-indent-function) (quote defun)))
(put (quote set-docsets!) (quote doom-module) (quote (:feature . lookup)))
(autoload (quote set-yas-minor-mode!) "~/.emacs.d/modules/feature/snippets/autoload/settings" "Register minor MODES (one mode symbol or a list of them) with yasnippet so it
can have its own snippets category, if the folder exists.

(fn MODES)" nil nil)
(put (quote set-yas-minor-mode!) (quote doom-module) (quote (:feature . snippets)))
(put (quote flyspell-mode!) (quote doom-file) "~/.emacs.d/modules/tools/flyspell/autoload.el")
(put (quote flyspell-mode!) (quote doom-module) (quote (:tools . flyspell)))
(defalias (quote flyspell-mode!) (function ignore) "THIS FUNCTION DOES NOTHING BECAUSE (:tools . flyspell) IS DISABLED

nil")
(put (quote set-flyspell-predicate!) (quote doom-file) "~/.emacs.d/modules/tools/flyspell/autoload.el")
(defmacro set-flyspell-predicate! (modes predicate) "THIS FUNCTION DOES NOTHING BECAUSE (:tools . flyspell) IS DISABLED

TODO" (ignore modes predicate))
(put (quote set-flyspell-predicate!) (quote doom-module) (quote (:tools . flyspell)))
(put (quote lsp!) (quote doom-file) "~/.emacs.d/modules/tools/lsp/autoload.el")
(put (quote lsp!) (quote doom-module) (quote (:tools . lsp)))
(defalias (quote lsp!) (function ignore) "THIS FUNCTION DOES NOTHING BECAUSE (:tools . lsp) IS DISABLED

nil")
(put (quote def-modeline-format!) (quote doom-file) "~/.emacs.d/modules/ui/modeline/autoload.el")
(put (quote def-modeline-format!) (quote doom-module) (quote (:ui . modeline)))
(defalias (quote def-modeline-format!) (function doom-modeline-def-modeline) nil)
(put (quote def-modeline-segment!) (quote doom-file) "~/.emacs.d/modules/ui/modeline/autoload.el")
(put (quote def-modeline-segment!) (quote doom-module) (quote (:ui . modeline)))
(defalias (quote def-modeline-segment!) (function doom-modeline-def-segment) nil)
(put (quote set-modeline!) (quote doom-file) "~/.emacs.d/modules/ui/modeline/autoload.el")
(put (quote set-modeline!) (quote doom-module) (quote (:ui . modeline)))
(defalias (quote set-modeline!) (function doom-modeline-set-modeline) nil)
(progn (autoload (quote set-popup-rule!) "~/.emacs.d/modules/ui/popup/autoload/settings" "Define a popup rule.

These rules affect buffers displayed with `pop-to-buffer' and `display-buffer'
(or their siblings). Buffers displayed with `switch-to-buffer' (and its
variants) will not be affected by these rules (as they are unaffected by
`display-buffer-alist', which powers the popup management system).

PREDICATE can be either a) a regexp string (matched against the buffer's name)
or b) a function that takes no arguments and returns a boolean.

PLIST can be made up of any of the following properties:

:ignore BOOL
  If BOOL is non-nil, popups matching PREDICATE will not be handled by the popup
  system. Use this for buffers that have their own window management system like
  magit or helm.

:actions ACTIONS
  ACTIONS is a list of functions or an alist containing (FUNCTION . ALIST). See
  `display-buffer''s second argument for more information on its format and what
  it accepts. If omitted, `+popup-default-display-buffer-actions' is used.

:side 'bottom|'top|'left|'right
  Which side of the frame to open the popup on. This is only respected if
  `+popup-display-buffer-stacked-side-window' or `display-buffer-in-side-window'
  is in :actions or `+popup-default-display-buffer-actions'.

:size/:width/:height FLOAT|INT|FN
  Determines the size of the popup. If more tha one of these size properties are
  given :size always takes precedence, and is mapped with window-width or
  window-height depending on what :side the popup is opened. Setting a height
  for a popup that opens on the left or right is harmless, but comes into play
  if two popups occupy the same :vslot.

  If a FLOAT (0 < x < 1), the number represents how much of the window will be
    consumed by the popup (a percentage).
  If an INT, the number determines the size in lines (height) or units of
    character width (width).
  If a function, it takes one argument: the popup window, and can do whatever it
    wants with it, typically resize it, like `+popup-shrink-to-fit'.

:slot/:vslot INT
  (This only applies to popups with a :side and only if :actions is blank or
  contains the `+popup-display-buffer-stacked-side-window' action) These control
  how multiple popups are laid out. INT can be any integer, positive and
  negative.

  :slot controls lateral positioning (e.g. the horizontal positioning for
    top/bottom popups, or vertical positioning for left/right popups).
  :vslot controls popup stacking (from the edge of the frame toward the center).

  Let's assume popup A and B are opened with :side 'bottom, in that order.
    If they possess the same :slot and :vslot, popup B will replace popup A.
    If popup B has a higher :slot, it will open to the right of popup A.
    If popup B has a lower :slot, it will open to the left of popup A.
    If popup B has a higher :vslot, it will open above popup A.
    If popup B has a lower :vslot, it will open below popup A.

:ttl INT|BOOL|FN
  Stands for time-to-live. It can be t, an integer, nil or a function. This
  controls how (and if) the popup system will clean up after the popup.

  If any non-zero integer, wait that many seconds before killing the buffer (and
    any associated processes).
  If 0, the buffer is immediately killed.
  If nil, the buffer won't be killed and is left to its own devices.
  If t, resort to the default :ttl in `+popup-defaults'. If none exists, this is
    the same as nil.
  If a function, it takes one argument: the target popup buffer. The popup
    system does nothing else and ignores the function's return value.

:quit FN|BOOL|'other|'current
  Can be t, 'other, 'current, nil, or a function. This determines the behavior
  of the ESC/C-g keys in or outside of popup windows.

  If t, close the popup if ESC/C-g is pressed anywhere.
  If 'other, close this popup if ESC/C-g is pressed outside of any popup. This
    is great for popups you may press ESC/C-g a lot in.
  If 'current, close the current popup if ESC/C-g is pressed from inside of the
    popup. This makes it harder to accidentally close a popup until you really
    want to.
  If nil, pressing ESC/C-g will never close this popup.
  If a function, it takes one argument: the to-be-closed popup window, and is
    run when ESC/C-g is pressed while that popup is open. It must return one of
    the other values to determine the fate of the popup.

:select BOOL|FN
  Can be a boolean or function. The boolean determines whether to focus the
  popup window after it opens (non-nil) or focus the origin window (nil).

  If a function, it takes two arguments: the popup window and originating window
    (where you were before the popup opened). The popup system does nothing else
    and ignores the function's return value.

:modeline BOOL|FN|LIST
  Can be t (show the default modeline), nil (show no modeline), a function that
  returns a modeline format or a valid value for `mode-line-format' to be used
  verbatim. The function takes no arguments and is run in the context of the
  popup buffer.

:autosave BOOL|FN
  This parameter determines what to do with modified buffers when closing popup
  windows. It accepts t, 'ignore, a function or nil.

  If t, no prompts. Just save them automatically (if they're file-visiting
    buffers). Same as 'ignore for non-file-visiting buffers.
  If nil (the default), prompt the user what to do if the buffer is
    file-visiting and modified.
  If 'ignore, no prompts, no saving. Just silently kill it.
  If a function, it is run with one argument: the popup buffer, and must return
    non-nil to save or nil to do nothing (but no prompts).

:parameters ALIST
  An alist of custom window parameters. See `(elisp)Window Parameters'.

If any of these are omitted, defaults derived from `+popup-defaults' will be
used.

(fn PREDICATE &key IGNORE ACTIONS SIDE SIZE WIDTH HEIGHT SLOT VSLOT TTL QUIT SELECT MODELINE AUTOSAVE PARAMETERS)" nil nil) (function-put (quote set-popup-rule!) (quote lisp-indent-function) (quote defun)))
(put (quote set-popup-rule!) (quote doom-module) (quote (:ui . popup)))
(progn (autoload (quote set-popup-rules!) "~/.emacs.d/modules/ui/popup/autoload/settings" "Defines multiple popup rules.

Every entry in RULESETS should be a list of alists where the CAR is the
predicate and CDR is a plist. See `set-popup-rule!' for details on the predicate
and plist.

Example:

  (set-popup-rules!
    '((\"^ \\*\" :slot 1 :vslot -1 :size #'+popup-shrink-to-fit)
      (\"^\\*\"  :slot 1 :vslot -1 :select t))
    '((\"^\\*Completions\" :slot -1 :vslot -2 :ttl 0)
      (\"^\\*Compil\\(?:ation\\|e-Log\\)\" :size 0.3 :ttl 0 :quit t)))

(fn &rest RULESETS)" nil nil) (function-put (quote set-popup-rules!) (quote lisp-indent-function) (quote 0)))
(put (quote set-popup-rules!) (quote doom-module) (quote (:ui . popup)))
(put (quote +pretty-code--correct-symbol-bounds) (quote doom-file) "~/.emacs.d/modules/ui/pretty-code/autoload.el")
(defmacro +pretty-code--correct-symbol-bounds (ligature-alist) "THIS FUNCTION DOES NOTHING BECAUSE (:ui . pretty-code) IS DISABLED

Prepend non-breaking spaces to a ligature.

This way `compose-region' (called by `prettify-symbols-mode') will use the
correct width of the symbols instead of the width measured by `char-width'." (ignore ligature-alist))
(put (quote +pretty-code--correct-symbol-bounds) (quote doom-module) (quote (:ui . pretty-code)))
(put (quote set-pretty-symbols!) (quote doom-file) "~/.emacs.d/modules/ui/pretty-code/autoload.el")
(defmacro set-pretty-symbols! (modes &rest plist) "THIS FUNCTION DOES NOTHING BECAUSE (:ui . pretty-code) IS DISABLED

Associates string patterns with icons in certain major-modes.

  MODES is a major mode symbol or a list of them.
  PLIST is a property list whose keys must match keys in `+pretty-code-symbols',
and whose values are strings representing the text to be replaced with that
symbol. If the car of PLIST is nil, then unset any pretty symbols previously
defined for MODES.

The following properties are special:

  :alist ALIST
    Appends ALIST to `prettify-symbols-alist' literally, without mapping text to
    `+pretty-code-symbols'.
  :merge BOOL
    If non-nil, merge with previously defined `prettify-symbols-alist',
    otherwise overwrite it.

For example, the rule for emacs-lisp-mode is very simple:

  (set-pretty-symbols! 'emacs-lisp-mode
    :lambda \"lambda\")

This will replace any instances of \"lambda\" in emacs-lisp-mode with the symbol
assicated with :lambda in `+pretty-code-symbols'.

Pretty symbols can be unset for emacs-lisp-mode with:

  (set-pretty-symbols! 'emacs-lisp-mode nil)" (ignore modes plist))
(put (quote set-pretty-symbols!) (quote doom-module) (quote (:ui . pretty-code)))

;;;***
